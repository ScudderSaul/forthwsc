//+---------------------------------------------------------------------------------------+
//This file codeelement.cpp is copyright 1999-2008 by Saul Scudder
//It is distributed for non-profit use as freeware and no warranty is given with the use of
//this source for any purpose whatsoever.
//This copyright notice is to remain unmodified in the file
//_Zen_Soft c/o 
//Saul Scudder
//358 E. Whitton
//Phoenix AZ 85012
//+---------------------------------------------------------------------------------------+

#include "stdafx.h"
#include <SYS\STAT.H> 
#include <cmath>
#include <cfloat>
#include <ctime>
#include "codeelement.h"
#include <fcntl.h>
#include <assert.h>
#include <cstdlib>
#include <cstdio>


#pragma warning(disable: 4786)

#include <vector>

using namespace std;

extern Language lang;

// ----------------------Errors----------------------


// Function name	: Errors::Errors
// Description	    : 
// RSData type		: 
Errors::Errors()
{   
  errors.reserve(80);
  ErrPrompt.reserve(120);
  ErrPrompt = "\nERROR:>";
  AddErr(NO_TRAILING_QUOTE,"No trailing quote ");           // error NO_TRAILING_QUOTE
  AddErr(SYNTAX_ERROR,"Syntax Error ");                     // error SYNTAX_ERROR
  AddErr(NO_SUCH_WORD,"No Such Word ");                     // error NO_SUCH_WORD
  AddErr(IS_NUMBER,"Trying to name a word with a number "); // error IS_NUMBER
  AddErr(WORD_EXISTS,"Word already exists ");               // error WORD_EXISTS 
  AddErr(BUFFER_END,"buffer end reached ");                 // error BUFFER_END
  AddErr(STACK_UNDERFLOW,"Stack Underflow ");               // error STACK_UNDERFLOW
  AddErr(AUX_STACK_UNDERFLOW, "The auxillary (control) stack has underflowed ");
  AddErr(ONLY_COMPILED,"May only be compiled in user words ");  // error ONLY_COMPILED
  AddErr(NO_BEGIN,"until without begin ");                  // error NO_BEGIN
  AddErr(NO_DO,"loop without do ");                         // error NO_DO
  AddErr(PRIMITIVE_EXISTS, "Primitive already exists ");
  AddErr(RETURN_STACK_UNDERFLOW, "RSData Stack Underflow ");
  AddErr(ILLEGALDEFINING, "Defining word: no use when in compile mode ");
  AddErr(DIVIDEBYZERO, "Divide by 0 ");
  AddErr(NO_CLOSINGPAREN, "No closing parenthisis ");
  AddErr(NO_EOL, "End of line not found? ");
  AddErr(BAD_STACKPOSITION, "Bad Stack position? ");
  AddErr(BAD_POINTER, "Not a valid pointer for use ");
  AddErr(NO_CREATE, "No created word ");
  AddErr(STL_ERROR, "STL sntax error ");
  AddErr(NO_CLASS_EXISTS, "No class exists for operation ");
  AddErr(CLASS_EXISTS, "A class exists with the given name ");
  AddErr(NO_MEMBER_FOUND, "class member does not exist ");
  AddErr(METHOD_EXISTED, "The method was already defined ");
  AddErr(COMPILING_METHOD, " Can't compile new method durring previous method compilation ");
  AddErr(NOT_COMPILING_METHOD, " Not compiling a method when called ");
  AddErr(MEMBER_EXISTS, "A class member of that name already existed ");
  AddErr(PRIVATE_METHOD, "The method is private or a protected member of the class ");
  AddErr(PRIVATE_MEMBER, "The class member is private or a protected member of the class ");
  AddErr(AMBIGUIOUS_MEMBER, " The name given resolves to several class members ");
  AddErr(SYSTEM_EXECPTION, "An exception was generated by the operating system ");
  AddErr(LOOP_INDEX_INVALID, "loop constructs are usable only in definitions");
  AddErr(UNKNOWNERROR, "Unknown Error");        // last
  
  for(int qq = 0;qq < 5;qq++)
  {
    LastError[qq].reserve(120);
  }

  fatal = false;
  ErrIndex = 0;
}


// Function name	: Errors::~Errors
// Description	    : 
// RSData type		: 
Errors::~Errors()
{

}

// Function name	: Errors::ShowError
// Description	    : 
// Return type		: void 
// Argument         : int ii
// Argument         : InterpreterData & intpr
void Errors::ShowError(int ii, InterpreterData & intpr, string& extra)
{
    fatal = true;
    ErrIndex++;
    if(ErrIndex > ERRLISTMAX)
    {
        ErrIndex = 0;
    }
    string ss;
    ss.reserve(240);
    ss = ErrPrompt + Error(ii);
    ss += extra;
    LastError[ErrIndex] = ss;
    
    intpr.Out() += LastError[ErrIndex];
    intpr.WriteOut();
    
    if(intpr.Tracing())
    {
        intpr.TraceOut(ss);
    }
    
    for (int kk = 0; kk < 5;kk++)
    {
        intpr.DecompileN(kk);
    }
    intpr.LineOut();
}

void Errors::ErrNumberError(long err, InterpreterData & intpr)
{
      intpr.Out() += strerror( errno );
      intpr.WriteOut();
}

// ------------------------Dictonary----------------------


// Function name	: Dictonary::Add
// Description	    : 
// Return type		: void 
// Argument         : Word & wrd
void Dictonary::Add(Word & wrd)
{
  words.push_back(wrd);
  vocs[current].AddWord(wrd.Name(), (words.size() - 1));
}

int Dictonary::Forget(string & wname)
{
   int nn;
   
   if((nn = Exists(wname)) != -1)
   {
      if(nn < mark)
      {
         nn = mark;
      }
      vector<Word> forgoten;
      vector<Word>::iterator kk, zz;
      int qq, rr;
      for(kk = (words.begin()  + nn), rr = nn;kk != words.end();kk++, rr++)
      {
         forgoten.push_back(*kk);  
         vector<Vocabulary>::iterator vi;
         for(vi = vocs.begin(); vi != vocs.end();vi++)
         {          
           if((qq = (*vi).Find((*kk).Name())) == rr)
           {
              (*vi).Erase((*kk).Name());
           }
         }
      }
      kk = words.begin() + nn;
      zz = words.end();
      words.erase(kk, zz);
      return(0);
   }
   else
   {
      return(-1);
   }
}

// Function name	: Dictonary::Exists
// Description	    : 
// Return type		: int 
// Argument         : CString& nam
int Dictonary::Exists(string& nam)
  {
    return(Find(nam));
  }


// Function name	: Dictonary::FindInContext
// Description	    : 
// Return type		: Word* 
// Argument         : string& nam
Word* Dictonary::FindInContext(string& nam)
 {
   int vn = vocs[context].Find(nam);

   if(vn >= 0)
   {
      if(words[vn].Name() == nam)   // extra check
      {
         return(&words[vn]);
      }
   }
   return(NULL);
 }

int Dictonary::Find(string& nam)
 {
   int vn = -1;
   list<int> ::iterator ii;    
   for(ii = vocorder.begin();ii != vocorder.end();ii++)
   {
     vn = vocs[(*ii)].Find(nam);
     if(vn >= 0)
     {
       break;
     }
   }
  return(vn);
 }


// Function name	: Dictonary::FindAddress
// Description	    : 
// Return type		: Word* 
// Argument         : string& nam
Word* Dictonary::FindAddress(string& nam)
 {
   int nn = Find(nam);
   if(nn >= 0)
   {
     if(words[nn].Name() == nam)   // temp check
     {
        return(&words[nn]);
     }
   }
   return(NULL);
 }


// Function name	: Dictonary::VocNameForWord
// Description	    : 
// Return type		: bool 
// Argument         : Word * ww
// Argument         : string& result
bool Dictonary::VocNameForWord(Word * ww , string& result)
{
  string sn;
  sn.reserve(60);
  sn = ww->Name();

   int vn = -1;
   list<int> ::iterator ii;    
   for(ii = vocorder.begin();ii != vocorder.end();ii++)
   {
     vn = vocs[(*ii)].Find(sn);
     if(vn != -1)
     {
       result = vocs[(*ii)].Name();
       return(true);
     }
   }
  return(false);  
}

// Function name	: Dictonary::Address
// Description	    : 
// Return type		: Word* 
// Argument         : int nn
Word* Dictonary::Address(int nn)
{
  return(&words[nn]);
}


// Function name	: Dictonary::Address
// Description	    : 
// Return type		: Word* 
// Argument         : CString& nam
Word* Dictonary::Address(string& nam)
{
//  int ind;

    return(FindAddress(nam));

//  if((ind = Exists(nam)) != -1)
//  {
//    return(&words[ind]);
//  }
//  else
//  {
//    return(NULL);
//  }
}

// Function name	: Dictonary::Address
// Description	    : 
// Return type		: Word* 
// Argument         : char* namw
Word* Dictonary::Address(char* namw)
{
  string nams;
  nams.reserve(60);
  nams = namw;
  return(Address(nams));
}


// Function name	: Dictonary::MostRecent
// Description	    : 
// Return type		: Word * 
// Argument         : void
Word * Dictonary::MostRecent(void)
{
  return(&words[(words.size() - 1)]);
}

// Function name	: Dictonary::Execute
// Description	    : 
// Return type		: void 
// Argument         : int wordindex
// Argument         : InterpreterData & idat
void Dictonary::Execute(int wordindex, InterpreterData & idat)
{
    try
    {
    words[wordindex].Execute(0, idat);
#ifdef USING_WINDOWS
    SleepEx(1, true);
#endif
    }
    catch(...)
    {
       string tres;
       VocNameForWord(Address(wordindex) , tres);
       string en = "c++ Exception from ";
       en += tres;
       idat.DebugTrace(tres); 
    }
}

// ---------------------------Language---------------------------

// Function name	: Language::Parse
// Description	    : 
// Return type		: int 
// Argument         : char * txt
int Language::Parse(char * txt, char *txtname)
{ 
    //  int errorv;
    char *wrd;
    string awrd;
    awrd.reserve(120);
    int wordindex;
    Element *anel = NULL;
    idat.ResetFatal();
//    if(idat.Tracing() == false)
//    {
//      idat.TraceOn();
//    }
    busy = true;
    idat.DebugTrace("Interpreter language Parser"); 
    
    Parser * par = idat.IParser();
    par->PushBuf(txt, txtname);
    
    while((wrd = par->NextWord()) != NULL)
    {
        anel = NULL;
        awrd = wrd;

        if(idat.ParseClass(awrd, par) == false)  // the word exists add the element
        {
            if((wordindex = idat.IDict()->Exists(awrd)) != -1)
            {    
                if((idat.IDict()->Address(wordindex)->FlagsMatch(idat.ExecuteCompile)))
                {
//                  idat.StartRunImmediate();                      
                }         
                idat.IDict()->Execute(wordindex, idat); // element added by word itself when compiling                             
                if((idat.IDict()->Address(wordindex)->FlagsMatch(idat.ExecuteCompile)))
                {
//                  idat.StopRunImmediate();                      
                }      
            }                
            else // word does not exist so see if its a digit
            {        
                if(idat.ParseDigits(wrd, par) == false)
                {                    
                   idat.ShowError(Errors::NO_SUCH_WORD, awrd);  
                   break;
                }
            }
        }
        if(idat.Fatal())
        {
//           par->PopBuf();
           break;
        }
    }
    idat.DebugTrace("Emptied input buffer");
        if(idat.Fatal())
        {
           idat.DebugTrace("fatal error in language, poping buffer"); 
           par->PopBuf();
           return(false);
        }    
        busy = false;

    return(true);
}


// Function name	: Language::Parse
// Description	    : 
// Return type		: int 
// Argument         : char * txt
int Language::Parse(string & intxt, string & intxtname)
{ 
    //  int errorv;
    char *wrd;
    string awrd;
    awrd.reserve(120);
    int wordindex;
    Element *anel = NULL;
    idat.ResetFatal();
    char *txt = NULL;
    char *txtname = NULL;
    busy = true;

    //    if(idat.Tracing() == false)
    //    {
    //      idat.TraceOn();
    //    }

    idat.DebugTrace("Interpreter language Parser"); 

    Parser * par = idat.IParser();

    try
    {
        txtname = new char[intxtname.size() + 1];
        if(txtname != NULL)
        {
            memcpy(txtname, intxtname.c_str(), intxtname.size());
            txtname[intxtname.size()] = 0;
        }
        txt = new char[intxt.size() + 1];
        if(txt != NULL)
        {
            memcpy(txt, intxt.c_str(), intxt.size());
            txt[intxt.size()] = 0;

            par->PushBuf(txt, txtname);

            while((wrd = par->NextWord()) != NULL)
            {
                anel = NULL;
                awrd = wrd;

                if(idat.ParseClass(awrd, par) == false)  // the word exists add the element
                {
                    if((wordindex = idat.IDict()->Exists(awrd)) != -1)
                    {    
                        if((idat.IDict()->Address(wordindex)->FlagsMatch(idat.ExecuteCompile)))
                        {
                            //                  idat.StartRunImmediate();                      
                        }         
                        idat.IDict()->Execute(wordindex, idat); // element added by word itself when compiling                             
                        if((idat.IDict()->Address(wordindex)->FlagsMatch(idat.ExecuteCompile)))
                        {
                            //                  idat.StopRunImmediate();                      
                        }      
                    }                
                    else // word does not exist so see if its a digit
                    {        
                        if(idat.ParseDigits(wrd, par) == false)
                        {                    
                            idat.ShowError(Errors::NO_SUCH_WORD, awrd);  
                            break;
                        }
                    }
                }
                if(idat.Fatal())
                {
                    //           par->PopBuf();
                    break;
                }
            }

        }
    }
    catch(...)
    {
        if(txt != NULL)
        {
            delete [] txt;
        }
        if(txtname != NULL)
        {
            delete [] txtname;
        }
        busy = false;
        idat.DebugTrace("Emptied input buffer");
        if(idat.Fatal())
        {
            idat.DebugTrace("fatal error in language, poping buffer"); 
            par->PopBuf();
            
            return(false);
        }  
        else
        {
            idat.DebugTrace("Extreme error in language, poping buffer"); 
            par->PopBuf();
            throw;
        }
    }
    busy = false;
    if(txt != NULL)
    {
        delete [] txt;
    }
    if(txtname != NULL)
    {
        delete [] txtname;
    }
    idat.DebugTrace("Emptied input buffer");
    if(idat.Fatal())
    {
        idat.DebugTrace("fatal error in language, poping buffer"); 
        par->PopBuf();
        return(false);
    }    

    return(true);
}


// ----------------------Element-----------------------------


// Function name	: Element::Execute
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & intrp
// Argument         : int imed
void Element::Execute(InterpreterData & intrp, int imed)
{
    Primitives *prim = intrp.ToPrimitives();

    try
    {
        switch(type)
        {
        case Primitive:         
            (prim->*fun)(intrp);
            break;
        case Literal:
            intrp.PushD(literal);
            break;
        case Definition:
            call->Execute(0, intrp, imed);
            break;
        case LitString:
            intrp.PushD(litstring);
            break;
        case AddressV:
            intrp.PushD((unsigned long) &literal);
            break;
        case MethodDefinition:
            method->Execute(0, intrp, imed);
            break;
        case DataDefinition:
            data->Resolve(intrp);
            break;
        default:
            break;
        }
    }
    catch(...)
    {
       throw;
    }
}



// Function name	: Element::SameWord
// Description	    : 
// Return type		: bool 
// Argument         : char *nam
// Argument         : InterpreterData & idat
bool Element::SameWord(char *nam, InterpreterData & idat)
{
  if(type == Definition)
  {
    Word *ww = (idat.IDict()->Address(nam));
    if(ww == call)
    {
       return(true);
    }
  }

  return(false);
}


// Function name	: Element::FetchDefinitionName
// Description	    : 
// Return type		: bool 
// Argument         : string & s
 bool Element::FetchDefinitionName(string & s)
 {
    if(type == Definition)
    {
      Word * ww = call;
      s = ww->Name();
      return(true);
    }
    else
    {
        if(type == MethodDefinition)
        {
           ClassMethod * md = method;
           s = md->Name();
           return(true);
        }
        else
        {
            if(type == DataDefinition)
            {
               ClassData * pd = data;
               s = pd->Name();
               return(true);
            }
        }
    }   
   return(false);
 }

// -------------------Word----------------------------------


// Function name	: Word::Execute
// Description	    : 
// Return type		: int 
// Argument         : int index
// Argument         : InterpreterData & intrp
// Argument         : int imed
 int Word::Execute(int index, InterpreterData & intrp, int imed)
 {
     unsigned long fm = 0;
//     bool savec = false;
     RSData rr(this);
     rr.SetIndex(index);
     int ty;
     
     if(intrp.Tracing())
     {
         string ts;
         ts.reserve(120);
         ts = " Entered word \"";
         ts += Name();
         ts+= "\" ";
         intrp.TraceOut(ts);
     }
     
     fm = FlagsMatch(intrp.ExecuteCompile);
     
     if(fm)
     {
//        intrp.StartRunImmediate();
     }

     if((intrp.Compiling() == false) || fm || imed)
     {
   
         intrp.SetExv(rr);
         while(intrp.ExvIndex() < word.size())
         {
             ty = word[intrp.ExvIndex()].Type();
             if(ty == Element::Definition || ty == Element::MethodDefinition)
             {
                 rr.SetIndex(intrp.ExvIndex());
                 intrp.PushR(rr);
             }
             
             try
             {
                 word[intrp.ExvIndex()].Execute(intrp, (imed | fm));
             }
             catch(...)
             {
#ifdef USING_WINDOWS
                 intrp.WindowsError();
#endif
                 intrp.ShowError(Errors::SYSTEM_EXECPTION, Name());
                 intrp.FatalError();
                 throw;
             }
             
             if(ty == Element::Definition  || ty == Element::MethodDefinition)
             {
                 intrp.SetExv(intrp.PopR());
                 rr = intrp.GetExv();
             }
             
             intrp.IncExv();
         }
//         if(fm)
//         {
//             intrp.SetCompiling(savec);
//         }
     }
     else
     {
         
          intrp.BuildAddElement(this);   
           
     }
     if(fm)
     {
//        intrp.StopRunImmediate();
     }
     
     if(intrp.Tracing())
     {
         string ds;
         ds.reserve(120);
         ds = " ---Exited word \"";
         ds += Name();
         ds += "\" ";
         intrp.TraceOut(ds);
     }
     
     return(Ok);
 }


// Function name	: Word::Decompile
// Description	    : 
// Return type		: void 
// Argument         : string& dtext
// Argument         : InterpreterData & intrp
void Word::Decompile(string& dtext, InterpreterData & intrp)
{
  dtext += "\nName: \"";
  dtext += name;
  dtext += "\"";
  char tstr[50]; 

  for(int ii = 0;ii < word.size();ii++)
  {
     int tt = word[ii].Type();
     sprintf(tstr,"\n-->Element %i is ", ii);
     dtext += tstr;
     unsigned long p1;
     string ss;
     ss.reserve(120);
     string ns;
     ns.reserve(120);

     switch (tt)
     {
       case Element::Primitive:
           dtext += " a primitive";
           break;
       case Element::Literal:
           dtext += " a literal == to ";
           word[ii].FetchLiteralVal(&p1);
           sprintf(tstr,"%i", p1);
           dtext += tstr;
           break;
       case Element::Definition:
           dtext += " a call to the word ";
           if(word[ii].FetchDefinitionName(ns))
           {
             dtext += (ns);
           }
           break;
       case Element::LitString:
           dtext += " a pointer to the string literal "; 
           word[ii].FetchLitString(ss);
           dtext += ss;
           break;
       case Element::AddressV:
           dtext += " a value set to ";
           word[ii].FetchLiteralVal(&p1);
           sprintf(tstr,"%i ", p1);
           dtext += tstr;
           break;
       case Element::MethodDefinition:
            dtext += " a call to the method "; 
            if(word[ii].FetchDefinitionName(ns))
            {
               dtext += (ns);
            }
            break;
       case Element::DataDefinition:
            dtext += " a referenve to the class data object "; 
            if(word[ii].FetchDefinitionName(ns))
            {
               dtext += (ns);
            }
            break;
       default:
           dtext += " Corrupt element of unknown type";
           break;
     }
     dtext += "\n\r";
  }
  dtext += "\n --End-of-decompile----"; 
}


// -------------------InterpreterData-----------------------



// Function name	: InterpreterData::InterpreterData
// Description	    : 
// Return type		: 
InterpreterData::InterpreterData()
 {
   dictonary = new Dictonary();
   usestdout = false;
   pparser = new Parser(this);
   cdescript = new ClassDescriptions();
   if(cdescript != NULL)
   {
      cdescript->SetInterpreterData(this);
   }
   compiling = false;
   immediate = false;
   numericbase = 10;
   nbufpos = 0;
   nbufflg = false;
   memset(nbuffer, 0, 60);
   INloc = 0;
   nwordbuf = wordbuf;

   retdepth = 0;
   OutFile = " ";
   char TraceStr[256];
   sprintf(TraceStr,".\\InterpTrace%i.txt",time(NULL));
   NewTraceFile(TraceStr);
   TraceOut("Started ");
   TraceOff();
   TraceToStringOff();
   ufcnt = 0;
   rets.reserve(200);
   dats.reserve(400);
   aux.reserve(200);
   tempintrp.reserve(300);
   Output.reserve(1000);
   OutFile.reserve(256);
   NoStdOut();
   NoStringOut();
   building = NULL;
 }


// Function name	: InterpreterData::InterpreterData
// Description	    : 
// Return type		: 
// Argument         : const InterpreterData& idat
InterpreterData::InterpreterData(const InterpreterData& idat)
 {
   rets.reserve(200);
   dats.reserve(400);
   aux.reserve(200);
   tempintrp.reserve(300);
   Output.reserve(1000);
   numericbase = idat.numericbase;
   nbufpos = idat.nbufpos;;
   nbufflg = idat.nbufflg;;
   memcpy(nbuffer, idat.nbuffer, 60);
   INloc = idat.INloc;
   nwordbuf = idat.nwordbuf;

   rets = idat.rets;
   dats = idat.dats;
   aux = idat.aux;
   dictonary = new Dictonary((*(idat.dictonary)));
   pparser = new Parser((*(idat.pparser)));
   cdescript = new ClassDescriptions(*(idat.cdescript));
   mmanager = idat.mmanager;
   allprim = idat.allprim;
   Err = idat.Err;
   immediate = idat.immediate;


   compiling = false;
   retdepth = 0;
   OutFile = " ";
   char TraceStr[256];
   sprintf(TraceStr,".\\InterpTrace%i.txt",time(NULL));
   NewTraceFile(TraceStr);
   TraceOut("Started ");
   TraceOff();
   NoStdOut();
   NoStringOut();
   ufcnt = 0;

   building = NULL;
 }


// Function name	: InterpreterData::operator = 
// Description	    : 
// Return type		: InterpreterData & 
// Argument         : const InterpreterData& idat
InterpreterData & InterpreterData::operator = (const InterpreterData& idat)
{
   rets.reserve(200);
   dats.reserve(400);
   aux.reserve(200);
   tempintrp.reserve(300);
   Output.reserve(1000);
   numericbase = idat.numericbase;
   nbufpos = idat.nbufpos;;
   nbufflg = idat.nbufflg;;
   memcpy(nbuffer, idat.nbuffer, 60);
   INloc = idat.INloc;
   nwordbuf = idat.nwordbuf;

   rets = idat.rets;
   dats = idat.dats;
   aux = idat.aux;
   dictonary = new Dictonary((*(idat.dictonary)));
   pparser = new Parser((*(idat.pparser)));
   cdescript = new ClassDescriptions(*(idat.cdescript));
   mmanager = idat.mmanager;
   allprim = idat.allprim;
   Err = idat.Err;

   compiling = false;
   immediate = idat.immediate;
   retdepth = 0;
   OutFile = " ";
   char TraceStr[256];
   sprintf(TraceStr,".\\InterpTrace%i.txt",time(NULL));
   NewTraceFile(TraceStr);
   TraceOut("Started ");
   TraceOff();
   ufcnt = 0;
   NoStdOut();
   NoStringOut();

   building = NULL;
   return(*this);
}


// Function name	: InterpreterData::~InterpreterData
// Description	    : 
// Return type		: 
InterpreterData::~InterpreterData()
 {
   if(outstream.is_open())
   {
      outstream.close();
   }

 if(tracestream.is_open())
   {
      tracestream.close();
   }

   while(!rets.empty())
   {
     rets.pop_back();
   }

   while(!dats.empty())
   {
     dats.pop_back();
   }

   while(!aux.empty())
   {
     aux.pop_back();
   }

   if(pparser != NULL)
   {
     delete pparser;
   }
  delete dictonary;
  if(cdescript != NULL)
  {
    delete cdescript;
  }
 }


// Function name	: InterpreterData::NameRunning
// Description	    : 
// Return type		: string& 
// Argument         : void
string& InterpreterData::NameRunning(void)
 {
   if(retdepth > 0)
   {
      Word* ww = exv0.Code();
      return((*ww).Name());
   }
   else
   {
      tempintrp = "Unknown";
      return(tempintrp);
   }
 }


// Function name	: InterpreterData::UseStdOut
// Description	    : 
// Return type		: void 
// Argument         : void
 void InterpreterData::UseStdOut(void)
 {
     usestdout = true;
     if(pparser != NULL)
     {
        pparser->UseStdOut();
     }
 }


// Function name	: InterpreterData::NoStdOut
// Description	    : 
// Return type		: void 
// Argument         : void
 void InterpreterData::NoStdOut(void)
 {
     usestdout = false;
     if(pparser != NULL)
     {
        pparser->NoStdOut();
     }
 }


// Function name	: InterpreterData::UseStringOut
// Description	    : 
// Return type		: void 
void InterpreterData::UseStringOut()
{
  usestringout = true;
  if(pparser != NULL)
   {
       pparser->NoStdOut();
   }
}


// Function name	: InterpreterData::NoStringOut
// Description	    : 
// Return type		: void 
void InterpreterData::NoStringOut()
{
  usestringout = false;
  if(pparser != NULL)
   {
       pparser->NoStdOut();
   }
}



// Function name	: InterpreterData::ParseContainedClass
// Description	    : 
// Return type		: void 
// Argument         : Parser * par
// Argument         : ClassDescription * nc
void InterpreterData::ParseContainedClass(Parser * par, ClassDescription * nc)
{
    char *zwrd;
    string szwrd;
    szwrd.reserve(120);
    string ncmp;
    ncmp.reserve(120);
    ncmp = "-:";
    Element *nel = NULL;
    char ntst[120];
    
    if(nc != NULL)
    {
        if((zwrd = par->NextWord()) != NULL)
        {
            szwrd = zwrd;
            sprintf(ntst, "%s == %s", szwrd.c_str(), ncmp.c_str());
            DebugTrace(ntst);
            if(szwrd == ncmp)
            {
                if((zwrd = par->NextWord()) != NULL)
                {
                    szwrd = zwrd; 
                    ClassMethod * pcm = NULL;
                    if((pcm = nc->MethodDesc(szwrd)) != NULL)
                    {
                        if(pcm->FlagsMatch(ClassMethod::Private) == 0 && pcm->FlagsMatch(ClassMethod::Protected) == 0)
                        {
                            Element *nel = new Element(pcm);
                            (Building())->AddElement(*nel);
                            delete nel;  
                        }
                        else
                        {
                            ShowError(Errors::PRIVATE_METHOD, szwrd);
                        }
                    }
                    else
                    {
                        ClassData * pcd = NULL;
                        if((pcd = nc->DataDesc(szwrd)) != NULL)
                        {
                            if(pcd->FlagsMatch(ClassData::Private) == 0 && pcd->FlagsMatch(ClassData::Protected) == 0)
                            {
                                Element *nel = new Element(pcd);
                                (Building())->AddElement(*nel);
                                delete nel;
                                if(pcd->IsClass())
                                {
                                    ClassDescription * rc = pcd->DClassDesc();
                                    ParseContainedClass(par, rc);
                                }      
                            }
                            else
                            {
                                ShowError(Errors::PRIVATE_METHOD, szwrd);
                            }
                        }
                        else
                        {
                            ShowError(Errors::NO_MEMBER_FOUND, szwrd);
                        }
                    }
                }
            }
            else
            {
                ShowError(Errors::SYNTAX_ERROR, szwrd);
            }
        }
        else
        {
            ShowError(Errors::BUFFER_END);
        }
    }
    else
    {
      ShowError(Errors::NO_CLASS_EXISTS);
    }
}


// Function name	: InterpreterData::ParseClass
// Description	    : 
// Return type		: bool 
// Argument         : string &awrd
// Argument         : Parser * par
bool InterpreterData::ParseClass(string &awrd, Parser * par)
{
  Element *anel = NULL;

         ClassDescription * pcd = ClassDSCR()->CompilingWhat();
         bool bv = false;
         if(pcd != NULL)
         {
           bv = pcd->IsMethodCompiling();
         }
         if(Compiling() && bv)
         {
      
              ClassMethod * pcm = NULL;
              if((pcm = pcd->MethodDesc(awrd)) != NULL)
              {
                 anel = new Element(((long)pcd));
                 (Building())->AddElement(*anel);
                 delete anel;   
                 string act;
                 act.reserve(256);
                 act = "this";
                 Word * thiscall = IDict()->Address(act);
                 anel = new Element(thiscall);
                 (Building())->AddElement(*anel);
                 delete anel;   
                 anel = new Element(pcm);
                 (Building())->AddElement(*anel);
                 delete anel;     
                 return(true);
              }
              else
              {
                  ClassData * pdd = NULL;
                  if((pdd = pcd->DataDesc(awrd)) != NULL)
                  {
                     char drdr[120];
                     sprintf(drdr, "Found data object in method %s, (Language parse)", pdd->Name().c_str());
                     DebugTrace(drdr);
                     anel = new Element(((long)pcd));
                     (Building())->AddElement(*anel);  // add cd
                     delete anel;   
                     string act;
                     act.reserve(256);
                     act = "this";
                     Word * thiscall = IDict()->Address(act);
                     anel = new Element(thiscall);
                     (Building())->AddElement(*anel);
                     delete anel;   
                     anel = new Element(pdd);
                     (Building())->AddElement(*anel);
                     if(pdd->IsClass() != 0)
                     {
                         DebugTrace("Class object found (Language parse)");
                         ClassDescription * nc = pdd->DClassDesc();
                         ParseContainedClass(par, nc);

                     }         
                     else
                     {
                        DebugTrace("data object was not class (Language parse)");
                     }
                     delete anel;
                     return(true);
                  }
                  else
                  {
                       //  "No Such Word"
                       return(false);
                  }
              }
         }
         else
         {
             //  "No Such Word"
             return(false);
         }
}


// Function name	: InterpreterData::ParseDigits
// Description	    : 
// Return type		: bool 
// Argument         : char *wrd
// Argument         : Parser * par
bool InterpreterData::ParseDigits(char *wrd, Parser * par)
{
    unsigned long aa;
    Element *anel = NULL;
    char * ws = &wrd[0];
    char * we = NULL;
  
//    if(par->AllDigits(wrd))  // is it a literal long ??
 //{
        if(Compiling())
        {
            aa = strtoul( ws, &we, numericbase);
            if(*we != 0)
            {
               return(false);
            }
            anel = new Element(aa);
            (Building())->AddElement(*anel);
            delete anel;
        }
        else
        {
            aa = strtoul( ws, &we, numericbase);
            if(*we != 0)
            {
               return(false);
            }
            PushD(aa);
        }
        return(true);
//    }
//    return(false);
}


// Function name	: InterpreterData::Parse
// Description	    : 
// Return type		: int 
// Argument         : char * txt
// Argument         : bool once
// Argument         : char * txtname
int InterpreterData::Parse(char * txt, bool once, char * txtname)
{ 
    //  int errorv;
    char *wrd;
    string awrd;
    awrd.reserve(120);
    int wordindex;
    Element *anel = NULL;
    ResetFatal();
//    if(Tracing() == false)
//    {
//      TraceOn();
//    }
    
    DebugTrace("Interpreter Data Parser"); 
    Parser * par = IParser();
    par->PushBuf(txt, txtname);
    
    while((wrd = par->NextWord(once)) != NULL)
    {
        anel = NULL;
        awrd = wrd;
              
        if(ParseClass(awrd, par) == false)
        {       
            if((wordindex = IDict()->Exists(awrd)) != -1)  // the word exists add the element
            {
                IDict()->Execute(wordindex, *this); // element added by word itself when compiling
            }
            else // word does not exist so see if its a digit or class method
            {             
               if(ParseDigits(wrd, par) == false)
               { 
                    //  "No Such Word"
                    ShowError(Errors::NO_SUCH_WORD, awrd);                    
               }
            }
        }
        if(Fatal())
        {
            par->PopBuf();
            DebugTrace("Fatal error in Interpreter poping buffer"); 
//            ResetFatal();
            break;
        }
    }
    DebugTrace("Emptied input buffer in interpreter");
    
    return(true);
}


// Function name	: InterpreterData::DecompileCurrent
// Description	    : 
// Return type		: void 
 void InterpreterData::DecompileCurrent()
 {
    if(retdepth > 0)
    {
      string dcs;
      char astr[50];

      RSData rv = exv0;
      rv.Code()->Decompile(dcs, *this);

      sprintf(astr," <<< Element %i is executing >>>\n", rv.Index());
      dcs += astr; 
      rv.Index();
      Out() += dcs;
      WriteOut();
      if(Tracing())
      {
        TraceOut(dcs);
      }
    }
 }


// Function name	: InterpreterData::DecompileOne
// Description	    : 
// Return type		: void 
 void InterpreterData::DecompileOne()
 {
    if(retdepth > 1)
    {
      string dcs;
      RSData rv = GetRsv(0);
      rv.Code()->Decompile(dcs, *this);

      char astr[60];
      sprintf(astr," <<< Element %i is executing >>>\n", rv.Index());
      dcs += astr;
      Out() += dcs;
      WriteOut();
      if(Tracing())
      {
        TraceOut(dcs);
      }
    }
 }



// Function name	: InterpreterData::DecompileN
// Description	    : 
// Return type		: void 
// Argument         : int n
 void InterpreterData::DecompileN(int n)
 {
    if(retdepth > n)
    {
      char astr[60];
      sprintf(astr, " \n----------RSData stack %i -----", n);
      string dcs = astr;
      RSData rv = GetRsv(n);
      rv.Code()->Decompile(dcs, *this); 
      sprintf(astr," \n<<< Element %i is executing >>>\n", rv.Index());

      dcs += astr;
      Out() += dcs;
      WriteOut();
      if(Tracing())
      {
        TraceOut(dcs);
      }
    }
 }


// Function name	: InterpreterData::BuildWithName
// Description	    : 
// Return type		: void 
// Argument         : string & name
 void InterpreterData::BuildWithName(string & name)
 {
   building = new Word();
   building->NewName(name);
 }

 void InterpreterData::BuildAddElement(Element& el)
 {
   building->AddElement(el);
 }


// Function name	: InterpreterData::BuildAddElement
// Description	    : 
// Return type		: void 
// Argument         : long qq
 void InterpreterData::BuildAddElement(long qq)
 {
   Element *pel = new Element(qq);
   building->AddElement(*pel);
   delete pel;
 }


// Function name	: InterpreterData::BuildAddElement
// Description	    : 
// Return type		: void 
// Argument         : long* pqq
 void InterpreterData::BuildAddElement(long* pqq)
 {
   Element *pel = new Element(pqq);
   building->AddElement(*pel);
   delete pel;
 }


// Function name	: InterpreterData::BuildAddElement
// Description	    : 
// Return type		: void 
// Argument         : string* pss
 void InterpreterData::BuildAddElement(string* pss)
 {
   Element *pel = new Element(pss);
   building->AddElement(*pel);
   delete pel;
 }


// Function name	: InterpreterData::BuildAddElement
// Description	    : 
// Return type		: void 
// Argument         : Word* pww
 void InterpreterData::BuildAddElement(Word* pww)
 {
   Element *pel = new Element(pww);
   building->AddElement(*pel);
   delete pel;
 }


// Function name	: InterpreterData::BuildAddElement
// Description	    : 
// Return type		: void 
// Argument         : ClassMethod* pm
 void InterpreterData::BuildAddElement(ClassMethod* pm)
 {
   Element *pel = new Element(pm);
   building->AddElement(*pel);
   delete pel;
 }

 void InterpreterData::BuildAddElement(ClassData* pd)
 {
   Element *pel = new Element(pd);
   building->AddElement(*pel);
   delete pel;
 }

 void InterpreterData::BuildFinishWord(void)
 {
   dictonary->Add(*building);
   delete building;
   building = NULL;
 }

 int InterpreterData::BuildLastUsedElement()
 {
    return((building->NextIndex() - 1));
 }

 int InterpreterData::BuildLastElementCalling(Word *pwrd)
 {
    int lu = BuildLastUsedElement();
    if(lu >= 0)
    {
       return((building->LastUse(pwrd, lu)));
    }
    else
    {
       return(-1);
    }
 }

// ------------ClassMethod----------------------------

 int ClassMethod::Execute(int index, InterpreterData & idat, int imed)
 {
     unsigned long fm;
//     bool savec;
     RSData rr(this);
     rr.SetIndex(index);
     int ty;
     
     if(idat.Tracing())
     {
         string ts;
         ts.reserve(120);
         ts = " Entered method \"";
         ts += Name();
         ts += "\" ";
         idat.TraceOut(ts);
     }
     
     char * tv = (char *) idat.PopD();
     ClassDescription * myclass = GetClassDescription();
     myclass->PushThis(tv);
     
     fm = FlagsMatch(idat.ExecuteCompile);
//     if(fm)
//     {
//         if(idat.Compiling())
//         {
//           savec = true;
//         }
//         idat.EndCompile();
//     }
     
     if((idat.Compiling() == false) || fm || imed)
     {
         idat.SetExv(rr);
         
         while(idat.ExvIndex() < method.size())
         {
             ty = method[idat.ExvIndex()].Type();
             if(ty == Element::Definition || ty == Element::MethodDefinition)
             {
                 rr.SetIndex(idat.ExvIndex());
                 idat.PushR(rr);
             }
             
             try
             {
                 method[idat.ExvIndex()].Execute(idat, (fm | imed));
             }
             catch(...)
             {
#ifdef USING_WINDOWS
                 idat.WindowsError();
#endif
                 idat.ShowError(Errors::SYSTEM_EXECPTION, Name());
                 throw;
             }
             
             if(ty == Element::Definition || ty == Element::MethodDefinition)
             {
                 idat.SetExv(idat.PopR());
                 rr = idat.GetExv();
             }
             
             idat.IncExv();
         }
//         if(fm)
//         {
//             idat.SetCompiling(savec);
//         }
     }
     else
     {
         idat.BuildAddElement(this);   
     }
     
     myclass->PopThis();
     if(idat.Tracing())
     {
         string ds;
         ds.reserve(120);
         ds = " ---Exited method \"";
         ds += Name();
         ds += "\" ";
         idat.TraceOut(ds);
     }
     
     return(0);
 }

void ClassMethod::Decompile(string& dtext, InterpreterData & intrp)
{
  dtext += "\nMethod Name: \"";
  dtext += name;
  dtext += "\"";
  char tstr[150]; 

  for(int ii = 0;ii < method.size();ii++)
  {
     int tt = method[ii].Type();
     sprintf(tstr,"\n-->Element %i is ", ii);
     dtext += tstr;
     unsigned long p1;
     string ss;
     ss.reserve(120);
     string ns;
     ns.reserve(120);

     switch (tt)
     {
       case Element::Primitive:
           dtext += " a primitive";
           break;
       case Element::Literal:
           dtext += " a literal == to ";
           method[ii].FetchLiteralVal(&p1);
           sprintf(tstr,"%i", p1);
           dtext += tstr;
           break;
       case Element::Definition:
           dtext += " a call to the word ";
           if(method[ii].FetchDefinitionName(ns))
           {
             dtext += (ns);
           }
           break;
       case Element::LitString:
           dtext += " a pointer to the string literal "; 
           method[ii].FetchLitString(ss);
           dtext += ss;
           break;
       case Element::AddressV:
           dtext += " a value set to ";
           method[ii].FetchLiteralVal(&p1);
           sprintf(tstr,"%i ", p1);
           dtext += tstr;
           break;
       case Element::MethodDefinition:
            dtext += " a call to the method "; 
            if(method[ii].FetchDefinitionName(ns))
            {
               dtext += (ns);
            }
            break;
       case Element::DataDefinition:
            dtext += " a reference to the class data object "; 
            if(method[ii].FetchDefinitionName(ns))
            {
               dtext += (ns);
            }
            break;
       default:
           dtext += " Corrupt element of unknown type";
           break;
     }
     dtext += "\n";
  }
  sprintf(tstr, "\n --End-of-decompile of %s----", Name().c_str());
  dtext += tstr;
}


// ---------------ClassData-------------------

 ClassData::ClassData(string & nam, unsigned long siz, ClassDescription *pc, 
     unsigned long num, ClassDescription *dc)
   {
      name.reserve(120);
      name = nam;
      flags = 0l;

      if(num > 1)
      {
        size = num *siz;
        number_of = num;
        element_size = siz;
        SetFlags(ArrayType);
      }
      else
      {
        size = siz;
        number_of = 1;
        element_size = siz; 
      }

      if(dc != NULL)
      {
        dclass_desc = dc;
        SetFlags(ClassType);
      }
      else
      {
        dclass_desc = NULL;
      }
  
      pclassdecription = pc;
      offset = pc->CurrentOffset();
   }

 int ClassData::Resolve(InterpreterData & idat)
 {
   long adr;

   if(idat.Tracing())
   {
      string ts;
      ts.reserve(120);
      ts = " Resolve Class data ";
      ts += Name();
      idat.TraceOut(ts);
   }

   char * tv = (char *) idat.PopD();
   ClassDescription * myclass = GetClassDescription();
   myclass->PushThis(tv);   

   char test1[200];

   if(FlagsMatch(ArrayType))
   {
     unsigned long nn = idat.PopD();
     adr = ((nn * element_size) + offset + ((long)myclass->ThisFront()));

     sprintf(test1, "Class Data %s array[index %li], element size %li, offset %li, class address %li, total %li", 
         Name().c_str(), nn, element_size, offset, ((long)myclass->ThisFront()), adr);
     idat.DebugTrace(test1); 

   }
   else
   {
     adr = (offset + ((long)myclass->ThisFront()));
      sprintf(test1, "Class Data %s offset %li, class address %li, total %li", 
         Name().c_str(), offset, ((long)myclass->ThisFront()), adr);
      idat.DebugTrace(test1); 
   }

//   if(FlagsMatch(ClassType))
//   {
 //    idat.PushD(((long)DClassDesc()));
//     idat.PushD((adr));
//   }
//   else
//   {
     idat.PushD((adr));
//  }

   myclass->PopThis();

 if(idat.Tracing())
  {
    string ds;
    ds.reserve(120);
    ds = " ---Exited Resolve class Data ";
    ds += Name();
    idat.TraceOut(ds);
  }

   return(0);
 }

 void ClassData::Decompile(string& dtext, InterpreterData & idat)
 {
   dtext += "\nName: \"";
   dtext += name;
   dtext += "\"";
   char astr[150];
   char cstr[150];
   char tstr[150];
   char pstr[150];

   if(IsPrivate())
   {
     sprintf(pstr, "A private ");
   }
   else
   {
     sprintf(pstr, "A public ");
   }

   if(IsClass())
   {
     sprintf(cstr, "class %s instance ",  DClassDesc()->Name().c_str());
   }
   else
   {
     sprintf(cstr, "object ");
   }

   if(Array())
   {
     sprintf(astr, "array of %li elements. each of %li bytes (total size = %li)", ElementNumber(), ElementSize(), Size());
   }
   else
   {
     sprintf(astr, "(size = %li)", Size());
   }

   sprintf(tstr, "%s%s%s", pstr, cstr, astr);
   dtext += tstr;
   sprintf(tstr, "\n --End-of-decompile of %s----", Name().c_str());
   dtext += tstr ;
 }


// ---------------ClassDescriptions-------------------
 

// Function name	: ClassDescription::ResetNamesForInherit
// Description	    : 
// Return type		: void 
// Argument         : string &prepend
 void ClassDescription::ResetNamesForInherit(string &prepend)
 {
     string nnam;
     string dnam;
     string ndnam;
     char ntxt[1024]; 
     
     nnam.reserve(1024);
     dnam.reserve(1024);
     ndnam.reserve(1024);
     nnam = ((prepend + "::") + Name());
     dnam = ("~" + Name());
     ndnam = ("~" + nnam);
     
     sprintf(ntxt, "Inherited %s becomes %s with constr name %s and destr name %s", 
         name.c_str(), nnam.c_str(), nnam.c_str(), ndnam.c_str());
     pidat->DebugTrace(ntxt);

     RenameMethod(name, nnam);
     RenameMethod(dnam, ndnam);
     SetName(nnam);
 }


// Function name	: ClassDescription::Inherit
// Description	    : 
// Return type		: void 
// Argument         : string &nam
// Argument         : unsigned long mode
 void ClassDescription::Inherit(string &nam, unsigned long mode)
 {
     map<string, ClassData, less<string> >:: iterator dt;
     map<string, ClassMethod, less<string> >:: iterator mt;
     ClassData * pdd;
     char ttxt[1024]; 

     ClassDescription * cd = pidat->ClassDSCR()->Find(nam);
     if(cd != NULL && cd != this)
     {
         ClassDescription cpyd = (*cd);
         cpyd.ResetNamesForInherit(Name());
         string nnam;
         nnam.reserve(1024);
         nnam = cpyd.Name();

         sprintf(ttxt, "%s := ' %i %s' as %s", Name().c_str(), cd, nam.c_str(), nnam.c_str());
         pidat->DebugTrace(ttxt);

    
         if(mode == ClassDescription::CompilePrivate)
         {
             cpyd.ResetAllPrivate();
         }
         else
         {
             if(mode == ClassDescription::CompileProtected)
             {
                 cpyd.ResetAllProtected();
             }
         }
        pidat->ClassDSCR()->AddInheritedDescription(cpyd);
        cd = pidat->ClassDSCR()->Find(nnam);
        if(cd == NULL)
        {
           pidat->DebugTrace(" NO new cd for inherit??"); 
        }

        sprintf(ttxt, "%s new object description inherited %s = %lx", name.c_str(), cd->Name().c_str(), cd);
        pidat->DebugTrace(ttxt);

        pdd = new ClassData(nnam, cpyd.Size(), this,  1, cd);
        AddData(*pdd);
        delete pdd;
        AddInheretedName(nnam);
     }
     else
     {
        pidat->ShowError(Errors::NO_CLASS_EXISTS, nam);
     }
 }


// Function name	: ClassDescription::InheritedClassDescription
// Description	    : 
// Return type		: ClassDescription * 
// Argument         : string & cn
 ClassDescription * ClassDescription::InheritedClassDescription(string & cn)
 {
    ClassDescription * pcd = pidat->ClassDSCR()->Find(cn);
    return(pcd);
 }


// Function name	: ClassDescription::InheritedClassData
// Description	    : 
// Return type		: ClassData * 
// Argument         : string & nam
 ClassData * ClassDescription::InheritedClassData(string & nam)
 {
     ClassData * ndat[5];
     ClassDescription * inhcl = NULL;
     int indix = 0;
     char ttxt[256];
     ndat[0] = NULL;

     for(int ii = 0; ii < inherited_order.size();ii++)
     {
         inhcl = InheritedClassDescription(inherited_order[ii]);
         if(inhcl != NULL)
         {
             sprintf(ttxt, "%s found inherited cd %s at %lx in InheritedClassData() (search for %s)", 
                 Name().c_str(), inhcl->Name().c_str(), inhcl, nam.c_str());
             pidat->DebugTrace(ttxt);
             ndat[indix] = inhcl->DataDesc(nam);
             if(ndat[indix] != NULL)
             {
                 sprintf(ttxt, "%s Found data in inherited %s", name.c_str(), ndat[indix]->Name().c_str());
                 pidat->DebugTrace(ttxt);
                 indix++;
                 if(indix > 4)
                 {
                   break;
                 }
             }
         }
         else
         {
             pidat->DebugTrace("NULL from InheritedClassDescription(inherited_order[ii])");
             // fatal error
         }
     }

     if(indix > 1)
     {
         sprintf(ttxt, "%s found ambiuguious names %s", name.c_str(), ndat[indix]->Name().c_str());
         pidat->DebugTrace(ttxt);
         // error ambiguious name
         pidat->ShowError(Errors::AMBIGUIOUS_MEMBER, nam);
     }

     return(ndat[0]);
 }


// Function name	: ClassDescription::PushInheritedThis
// Description	    : 
// Return type		: void 
// Argument         : char * nths
 void ClassDescription::PushInheritedThis(char * nths)
 {
     ClassData * ndat = NULL;
     ClassDescription * inhcl = NULL;
     for(int ii = 0; ii < inherited_order.size();ii++)
     {
         inhcl = InheritedClassDescription(inherited_order[ii]);
         ndat = DataDesc(inherited_order[ii]);
         if(ndat != NULL)
         {
             inhcl->PushThis((ndat->Offset() + nths));
         }
         else
         {
             // error ambiguious name
             pidat->ShowError(Errors::AMBIGUIOUS_MEMBER);
             break;
         }
     }
 }


// Function name	: ClassDescription::PopInheritedThis
// Description	    : 
// Return type		: void 
// Argument         : void
 void ClassDescription::PopInheritedThis(void)
 {
     ClassData * ndat = NULL;
     ClassDescription * inhcl = NULL;
     for(int ii = 0; ii < inherited_order.size();ii++)
     {
         inhcl = InheritedClassDescription(inherited_order[ii]);
         ndat = DataDesc(inherited_order[ii]);
         if(ndat != NULL)
         {
             inhcl->PopThis();
         }
         else
         {
             // error ambiguious name
             pidat->ShowError(Errors::AMBIGUIOUS_MEMBER);
             break;
         }
     }
 }
 

// Function name	: ClassDescription::InheritedClassMethod
// Description	    : 
// Return type		: ClassMethod * 
// Argument         : string & nam
 ClassMethod * ClassDescription::InheritedClassMethod(string & nam)
 {
     ClassMethod* ndat[5];
     ClassDescription * inhcl = NULL;
     int indix = 0;
     char ttxt[100];
     ndat[0] = NULL;

     for(int ii = 0; ii < inherited_order.size();ii++)
     {
         inhcl = InheritedClassDescription(inherited_order[ii]);
         if(inhcl != NULL)
         {
             sprintf(ttxt, "found inherited cd %s %lx in InheritedClassMethod() (search for %s)", 
                 inhcl->Name().c_str(), inhcl, nam.c_str());
             pidat->DebugTrace(ttxt);

             ndat[indix] = inhcl->MethodDesc(nam);

             if(ndat[indix] != NULL)
             {
                 sprintf(ttxt, "Found method in inherited %s", ndat[indix]->Name().c_str());
                 pidat->DebugTrace(ttxt);
                 indix++;
                 if(indix > 4)
                 {
                   break;
                 }
             }
         }
         else
         {
             pidat->DebugTrace("NULL from InheritedClassDescription(inherited_order[ii])");
             // fatal error
         }
     }

     if(indix > 1)
     {
         sprintf(ttxt, "ambiuguious method name %s", ndat[indix]->Name().c_str());
         pidat->DebugTrace(ttxt);
         // error ambiguious name
         pidat->ShowError(Errors::AMBIGUIOUS_MEMBER, nam);
     }

     return(ndat[0]);
 }
 

// Function name	: ClassDescription::CallDestructor
// Description	    : 
// Return type		: void 
// Argument         : void
 void ClassDescription::CallDestructor(void)
 {
     string gn;
     gn.reserve(512);
     gn = "~";
     gn += Name();
     ClassDescription * inhcl = NULL;
     int kk = inherited_order.size() - 1;
     ClassMethod * pm = NULL;
     
     char * tt = (char *) pidat->PopD();
     if(tt != NULL)
     {
         PushThis(tt);
         
         for(int ii = kk; ii >= 0;ii--)
         {
             inhcl = InheritedClassDescription(inherited_order[ii]);
             if(inhcl != NULL)
             {
                 pidat->PushD((long)inhcl->ThisFront());
                 inhcl->CallDestructor();
             }
         }
         PopThis();
         if((pm = MethodDesc(gn)) != NULL)
         {
             pidat->PushD((long)tt);
             pm->Execute(0, *pidat);
         }
     }
 }


// Function name	: ClassDescription::CallConstructor
// Description	    : 
// Return type		: void 
// Argument         : char * tt
void ClassDescription::CallConstructor(char * tt)
 {
     string gn;
     gn.reserve(512);
     gn = Name();
     ClassDescription * inhcl = NULL;
     int kk = inherited_order.size() - 1;
     ClassMethod * pm = NULL;
     char atxt[1024];
     sprintf(atxt, "%s Calling constructors for instance %lx", Name().c_str(), tt); 
     pidat->DebugTrace(atxt);
     
     if(tt != NULL)
     {
         PushThis(tt);
         for(int ii = kk; ii >= 0;ii--)
         {
             inhcl = InheritedClassDescription(inherited_order[ii]);
             if(inhcl != NULL)
             {
                 char * nn = inhcl->ThisFront();
                 sprintf(atxt, "%s inherited a constructor for %s at %lx", Name().c_str(), inhcl->Name().c_str(), nn); 
                 pidat->DebugTrace(atxt);
                 inhcl->CallConstructor(nn);
             }
         }
         PopThis();

         map<string, ClassMethod, less<string> >::iterator jj;
         jj = methods.find(name);
      
         if(jj == methods.end())
         {
             sprintf(atxt, "%s instance NULL constructor", name.c_str()); 
             pidat->DebugTrace(atxt);            
         }
         else
         { 
             pm = &(*jj).second;
             pidat->PushD((long)tt);
             sprintf(atxt, " %s instance %lx executing method %s", name.c_str(), tt, pm->Name().c_str()); 
             pidat->DebugTrace(atxt);
             pm->Execute(0, *pidat);
         }
     }
 }


// ---------------Primitives---------------------------


// Function name	: Primitives::L_plus
// Description	    : ( a b -- a+b )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_plus(InterpreterData & idat)
 {
   long aa = idat.PopD();
   long bb = idat.PopD();
   idat.PushD(aa + bb);
 }


// Function name	: Primitives::L_minus
// Description	    : ( b a -- a-b )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_minus(InterpreterData & idat)
 {
   long aa = idat.PopD();
   long bb = idat.PopD();
   idat.PushD(bb - aa);
 }

void Primitives::L_runif(InterpreterData & idat)
{
    int tind = idat.PopD();
    //      sprintf(twom, "stack in if poped tind %li", tind);
    //      idat.DebugTrace(twom);
    int eind = idat.PopD();
    //      sprintf(twom, "stack in if poped eind %li", eind);
    //      idat.DebugTrace(twom);
    long aa = idat.PopD();
    //      sprintf(twom, "stack in if poped testv %li", aa);
    //      idat.DebugTrace(twom);
    if(aa != 0)
    {
        return;
    }
    RSData ar = idat.GetRsv(0);
    if(eind < tind && eind > 0)
    {
        //        sprintf(twom, "if's  eind < tind && eind > 0 go to (else)ind");
        //        idat.DebugTrace(twom);
        ar.SetIndex(eind); 
        idat.SetRsv(ar, 0);
    }
    else
    {
        if(tind > 0)
        {
            //          sprintf(twom, "if's tind > 0 go to (then)ind");
            //          idat.DebugTrace(twom);
            
            ar.SetIndex(tind);    // index set to then
            idat.SetRsv(ar, 0);
        }
    }
}

// Function name	: Primitives::L_if
// Description	    : 
//    When called the current word is if and word second
//    on the return stack is the word with the if .. then
// Return type		: void 
// Argument         : InterpreterData & idat

void Primitives::L_if(InterpreterData & idat)
 {
//   char twom[60];     
   
   if(idat.Compiling())
   {
      idat.BuildAddElement((long) -1);           // for else index
      idat.BuildAddElement((long) -1);           // for then index
      Word *fif;
      string Bif = "runif";
      fif = idat.IDict()->Address(Bif);
      idat.BuildAddElement(fif);
      long ee = idat.BuildLastUsedElement();   
//      sprintf(twom, "ADPush two 'if' index = %li", ee);
//      idat.DebugTrace(twom);      
      idat.PushLabeledAD((unsigned long) fif, ee);
//      sprintf(twom, "ADPush two 'else' index = %li", -1);
//      idat.DebugTrace(twom);      
      idat.PushLabeledAD("runelse", -1);
   }
   else
   {
      int tind = idat.PopD();
//      sprintf(twom, "stack in if poped tind %li", tind);
//      idat.DebugTrace(twom);
      int eind = idat.PopD();
//      sprintf(twom, "stack in if poped eind %li", eind);
//      idat.DebugTrace(twom);
      long aa = idat.PopD();
//      sprintf(twom, "stack in if poped testv %li", aa);
//      idat.DebugTrace(twom);
      if(aa != 0)
      {
         return;
      }
      RSData ar = idat.GetRsv(0);
      if(eind < tind && eind > 0)
      {
//        sprintf(twom, "if's  eind < tind && eind > 0 go to (else)ind");
//        idat.DebugTrace(twom);
        ar.SetIndex(eind); 
        idat.SetRsv(ar, 0);
      }
      else
      {
        if(tind > 0)
        {
//          sprintf(twom, "if's tind > 0 go to (then)ind");
//          idat.DebugTrace(twom);

          ar.SetIndex(tind);    // index set to then
          idat.SetRsv(ar, 0);
        }
      }
   }
 }

// Function name	: Primitives::L_else
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_runelse(InterpreterData & idat)
{
       int tind = idat.PopD();
       RSData ar = idat.GetRsv(0);
       ar.SetIndex(tind); 
       idat.SetRsv(ar, 0);  
}

// Function name	: Primitives::L_else
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_else(InterpreterData & idat)
 {
   if(idat.Compiling())
   {
      idat.PopLabeledAD();
      unsigned long ifi = idat.PopLabeledAD();  
      unsigned long ifeind = ifi - 2;

      idat.PushLabeledAD("runif", ifi);

      idat.BuildAddElement((long) -1);   // for then index 
      
      string Belse = "runelse";
      Word *felse = idat.IDict()->Address(Belse);
      idat.BuildAddElement(felse);
      unsigned long ee = idat.BuildLastUsedElement();           // testing
      idat.Building()->SetLiteralValue(ifeind, &ee);
      idat.PushLabeledAD("runelse", ee);
   }
   else
   {
       int tind = idat.PopD();
       RSData ar = idat.GetRsv(0);
       ar.SetIndex(tind); 
       idat.SetRsv(ar, 0);
   }
 }


// Function name	: Primitives::L_nop
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_nop(InterpreterData & idat)
 {
   int nn = 1;  // nop
 }

// Function name	: Primitives::L_then
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_runthen(InterpreterData & idat)
{
 ;  
}

// Function name	: Primitives::L_then
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_then(InterpreterData & idat)
 {
//  char twom[60];     

   if(idat.Compiling())
   {
      long elsei = idat.PopLabeledAD() - 1;        // else index - 1
      long ifi = idat.PopLabeledAD() - 1;          // if index - 1

//      sprintf(twom, "PolLAD then of 'else' index = %li", elsei);
//      idat.DebugTrace(twom);         
//      sprintf(twom, "PolLAD then of 'if' index = %li", ifi); 
//      idat.DebugTrace(twom);    

      string Bthen = "runthen";
      Word *fthen = idat.IDict()->Address(Bthen);

      idat.BuildAddElement(fthen);
      unsigned long ee = idat.BuildLastUsedElement();

//      sprintf(twom, "PolLAD then found ifi index = %li", ee);
//      idat.DebugTrace(twom);         

      idat.Building()->SetLiteralValue(ifi, &ee);
      if(elsei > 1)
      {
        idat.Building()->SetLiteralValue(elsei, &ee);
      }
   }
 }

// Function name	: Primitives::L_colon
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_colon(InterpreterData & idat)
{
  string awrd;
  Parser * par = idat.IParser();
  char * wrd;

  if(idat.Compiling())
  {
     // already compiling a new word error

      return;
  }

  if((wrd = par->NextWord()) != NULL)
  {
     awrd = wrd;
     if(idat.IDict()->Exists(awrd) == -1)  // word does not exist
     {
       if(!par->AllDigits(wrd))  // word is not a number
       {
         idat.BuildWithName(awrd);
         idat.Compile();
       }
       else
       {
          // trying to name a word with a number error
          idat.ShowError(Errors::IS_NUMBER);
       }
     }
     else
     {
        // word already exists error
        idat.ShowError(Errors::WORD_EXISTS , awrd);
     }
  } 
  else
  {
      // buffer end reached
      idat.ShowError(Errors::BUFFER_END);
  }
}


// Function name	: Primitives::L_semicolon
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_semicolon(InterpreterData & idat)
{
 if(idat.Compiling())
  {
    idat.EndCompile();
    idat.BuildFinishWord();
  }
 else
 {
    // Show Error 1 Syntax error
     idat.ShowError(Errors::SYNTAX_ERROR);
 }
}


// Function name	: Primitives::L_quote
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_quote(InterpreterData & idat)
{
 string *textliteral = NULL;
 Parser * par = idat.IParser(); 

 if(idat.Compiling())
  {
    textliteral = new string();
    textliteral->reserve(200);

    if(par->GetAny(*textliteral, false, '"'))
    {
        idat.BuildAddElement(textliteral);
        par->Advance();
    }
    else  // no trailing quote
    {
        // Show Error 0 no trialing quote 
        delete textliteral;
        idat.ShowError(Errors::NO_TRAILING_QUOTE);
    } 
  }
 else
 {
    idat.EmptyTempString();
    if(par->GetAny(idat.TempString(), false, '"'))
    {
//      idat.DebugTrace(" L_quote has string"); 
      idat.PushD(&idat.TempString()); 
      par->Advance();
    }
    else  // no trailing quote
    {
        // Show Error 0 no trialing quote 
        idat.ShowError(Errors::NO_TRAILING_QUOTE);
    } 
 }
}


// Function name	: Primitives::L_dotquote
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_dotquote(InterpreterData & idat)
{
 string *textliteral;
 Parser * par = idat.IParser(); 

 if(idat.Compiling())
  {
    textliteral = new string();
    textliteral->reserve(300);

    if(par->GetAny(*textliteral, false, '"'))
    {
        idat.BuildAddElement(textliteral);
        par->Advance();
        string Bps = "printstring";
        Word *fps = idat.IDict()->Address(Bps);
        idat.BuildAddElement(fps);
    }
    else  // no trailing quote
    {
        // Show Error 0 no trialing quote 
        idat.ShowError(Errors::NO_TRAILING_QUOTE);
    } 
  }
 else
 {
//   L_printstring(idat); 
 }
}

// Function name	: Primitives::L_dotquote
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_squote(InterpreterData & idat)
{
 string *textliteral;
 Parser * par = idat.IParser(); 

 if(idat.Compiling())
  {
    textliteral = new string();
    textliteral->reserve(300);

    if(par->GetAny(*textliteral, false, '"'))  // add room for the 's" '
    {
        int sz = textliteral->size();
        
        void * vp = idat.MManager().AllocateType(MemInstDat::m_CharArray, (sz + 6));
        char * np = ((((char*) vp) + 4));
        memcpy(np, textliteral->c_str(), sz);
        np[sz] = 0;
        np[sz+1] = 0;
        delete textliteral;
        idat.BuildAddElement((long)np);
        idat.BuildAddElement((long)sz);
        par->Advance();
    }
    else  // no trailing quote
    {
        // Show Error 0 no trialing quote 
        idat.ShowError(Errors::NO_TRAILING_QUOTE);
    } 
  }
}

// Function name	: Primitives::L_dotquote
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_cquote(InterpreterData & idat)
{
 string *textliteral;
 Parser * par = idat.IParser(); 

 if(idat.Compiling())
  {
    textliteral = new string();
    textliteral->reserve(300);

    if(par->GetAny(*textliteral, false, '"'))  // add room for the 'c" '
    {
        int sz = textliteral->size();
        
        void * vp = idat.MManager().AllocateType(MemInstDat::m_CharArray, (sz + 6));
        char * np = ((((char*) vp) + 4));
        long * lp = (long*) vp;
        *lp = sz;
        memcpy(np, textliteral->c_str(), sz);
        np[sz] = 0;
        delete textliteral;
        idat.BuildAddElement((long)vp);
        par->Advance();
    }
    else  // no trailing quote
    {
        // Show Error 0 no trialing quote 
        idat.ShowError(Errors::NO_TRAILING_QUOTE);
    } 
  }
}



// Function name	: Primitives::EndParen
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_Comment(InterpreterData & idat)
{
 string textliteral;

 textliteral.reserve(200);
 Parser * par = idat.IParser(); 

 if(idat.Compiling())
  {
    if(!par->GetAny(textliteral, false, ')'))
    {
        idat.ShowError(Errors::NO_CLOSINGPAREN);
    } 
    par->Advance();
  }
 else
 {
    if(!par->GetAny(textliteral, false, ')'))
    {
        idat.ShowError(Errors::NO_CLOSINGPAREN);
    } 
    par->Advance();
 }
}

// Function name	: Primitives::L_CppComment
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_CppComment(InterpreterData & idat)
{
 Parser * par = idat.IParser(); 

 if(idat.Compiling())
  {
    if(!par->NewLine(false))
    {
        idat.ShowError(Errors::NO_EOL);
    } 
  }
 else
 {
    if(!par->NewLine(false))
    {
        idat.ShowError(Errors::NO_EOL);
    } 
 }
}

// Function name	: Primitives::L_ForthComment
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_ForthComment(InterpreterData & idat)
{
 string textliteral;
 Parser * par = idat.IParser();  

 if(idat.Compiling())
  {
    if(!par->NewLine(false))
    {
        idat.ShowError(Errors::NO_EOL);
    } 
  }
 else
 {
    if(!par->NewLine(false))
    {
        idat.ShowError(Errors::NO_EOL);
    } 
 }
}

// Function name	: Primitives::L_dot
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_dot(InterpreterData & idat)
{
  char ss[35];
  idat.Out() +=  _ltoa( idat.PopD(), ss, *idat.Base());
  idat.Out() += " ";
  idat.WriteOut();
}

// Function name	: Primitives::L_space
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_space(InterpreterData & idat)
{
  idat.Out() += " ";
  idat.WriteOut();
}

// Function name	: Primitives::L_space
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_spaces(InterpreterData & idat)
{
  unsigned long s = idat.PopD();
  for(int ii = 0;ii < s;ii++)
  {
    idat.Out() += " ";
  }
  idat.WriteOut();
}

// Function name	: Primitives::L_udot
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_udot(InterpreterData & idat)
{
  unsigned long aa = idat.PopD();
  char ss[35];
  idat.Out() += _ultoa(aa, ss, *idat.Base());
  idat.Out() += " ";
  idat.WriteOut();
}

__int64 Primitives::Pop64(InterpreterData & idat)
{
   __int64 aa;
   
   unsigned long *high = (((unsigned long *)&aa) + 1);
   unsigned long *low = (unsigned long *)&aa;
   *high = idat.PopD();
   *low = idat.PopD();

   return(aa);
}

void Primitives::Push64(unsigned __int64 vv, InterpreterData & idat)
{
   unsigned __int64 aa = vv;
   
   unsigned long *high = (((unsigned long *)&aa) + 1);
   unsigned long *low = (unsigned long *)&aa;
   
   idat.PushD(((unsigned long) *low));
   idat.PushD(((unsigned long) *high));
}

// Function name	: Primitives::L_ddot
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_ddot(InterpreterData & idat)
{
  __int64 aa = Pop64(idat);
  char ss[70];
  idat.Out() += _i64toa(aa, ss, *idat.Base());
  idat.Out() += " ";
  idat.WriteOut();
}

// Function name	: Primitives::L_dudot
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_dudot(InterpreterData & idat)
{
  unsigned __int64 aa = Pop64(idat);
  char ss[70];
  idat.Out() += _ui64toa(aa, ss, *idat.Base());
  idat.Out() += " ";
  idat.WriteOut();
}

// Function name	: Primitives::dplus
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_dplus(InterpreterData & idat)
{
  __int64 aa = Pop64(idat);
  __int64 bb = Pop64(idat);
  Push64((aa + bb), idat);
}

// Function name	: Primitives::L_dtwostar
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_dtwostar(InterpreterData & idat)
{
  __int64 aa = Pop64(idat);
  Push64((aa << 1), idat);
}

// Function name	: Primitives::L_dtwoslash
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_dtwoslash(InterpreterData & idat)
{
  __int64 aa = Pop64(idat);
  Push64((aa >> 1), idat);
}

// Function name	: Primitives::dplus
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_dnegate(InterpreterData & idat)
{
  __int64 aa = -Pop64(idat);
  Push64(aa, idat);
}

// Function name	: Primitives::L_dzeroless
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_dzeroless(InterpreterData & idat)
{
  __int64 aa = Pop64(idat);
  if(aa < ((__int64)0l))
  {
    idat.PushD(-1);
  }
  else
  {
    idat.PushD(0l);
  }
}

// Function name	: Primitives::L_dmax
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_dmax(InterpreterData & idat)
{
  __int64 aa = Pop64(idat);
  __int64 bb = Pop64(idat);

  if(aa < bb)
  {
    Push64(bb, idat);
  }
  else
  {
    Push64(aa, idat);
  }
}

// Function name	: Primitives::L_dmin
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_dmin(InterpreterData & idat)
{
  __int64 aa = Pop64(idat);
  __int64 bb = Pop64(idat);

  if(aa < bb)
  {
    Push64(aa, idat);
  }
  else
  {
    Push64(bb, idat);
  }
}

// Function name	: Primitives::L_dzeroequal
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_dzeroequal(InterpreterData & idat)
{
  __int64 aa = Pop64(idat);
  if(aa < ((__int64)0l))
  {
    idat.PushD(-1);
  }
  else
  {
    idat.PushD(0l);
  }
}

// Function name	: Primitives::dminus
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_dminus(InterpreterData & idat)
{
  __int64 aa = Pop64(idat);
  __int64 bb = Pop64(idat);
  Push64((bb - 11), idat);
}

// Function name	: Primitives::L_sgreaterd
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_sTod(InterpreterData & idat)
{
  __int64 aa = (__int64 ) idat.PopD();

 // sprintf(ss," %lu ",aa);
 idat.PushD(*((unsigned long *)&aa));
 idat.PushD(*(((unsigned long *)&aa) + 1));
}

// Function name	: Primitives:L_umtimes
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_mtimes(InterpreterData & idat)
{
   unsigned __int64 aa = (__int64 )idat.PopD();
   unsigned __int64 bb = (__int64 )idat.PopD();
   unsigned __int64 cc = aa * bb;

   Push64(cc, idat);
}

// Function name	: Primitives:L_mtimes
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_umtimes(InterpreterData & idat)
{
 unsigned __int64 aa = (__int64 )idat.PopD();
 unsigned __int64 bb = (__int64 )idat.PopD();
 unsigned __int64 cc = aa * bb;

 Push64(cc, idat);
}

// Function name	: Primitives:L_smslashrem
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_umslashmod(InterpreterData & idat)
{
   unsigned __int64 divi = (__int64 )idat.PopD();
   unsigned __int64 tg = Pop64(idat);
   unsigned long q = (unsigned long) (tg / divi);
   unsigned long m = (unsigned long) (tg % divi);

 idat.PushD(m);
 idat.PushD(q);
}

// Function name	: Primitives:L_smslashrem
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_smslashrem(InterpreterData & idat)
{
   __int64 divi = (__int64 )idat.PopD();
   __int64 tg = Pop64(idat);
   __int64 q = tg / divi;
   __int64 m = tg % divi;

 idat.PushD((long)m);
 idat.PushD((long)q);
}

// Function name	: Primitives:L_fmslashmod
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_fmslashmod(InterpreterData & idat)
{
   __int64 divi = (__int64 )idat.PopD();
   __int64 tg = Pop64(idat);
   __int64 q = tg / divi;
   __int64 m = tg % divi;
   if(m != (__int64)0)
   {
      if((tg > ((__int64)0)))
      {
          if(divi < ((__int64)0))
          {
             m =  (((__int64)-1) - m); 
             q -= ((__int64)1.0);
          }
      }
      else
      {
          if(divi > ((__int64)0))
          {
            q -= ((__int64)1.0);
            m = (((__int64)1) - m); 
          }
      }
   }

 // sprintf(ss," %lu ",aa);
 idat.PushD((long)m);
 idat.PushD((long)q);
}



// Function name	: Primitives::L_emit
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_emit(InterpreterData & idat)
{
  long aa = idat.PopD();
  char ss[25];
  sprintf(ss,"%c",aa);
  idat.Out() += ss;
  idat.WriteOut();
}

void Primitives::L_CR(InterpreterData & idat)
{
  idat.LineOut();
}

// Function name	: Primitives::L_printstring
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_printstring(InterpreterData & idat)
{
  string *ss = (string *) ((void *) idat.PopD());
  idat.DebugString(ss->c_str());
  idat.Out() += (*ss);
  idat.WriteOut();
}


// Function name	: Primitives::L_begin
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_runbegin(InterpreterData & idat)
{
 ;
}

// Function name	: Primitives::L_begin
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_begin(InterpreterData & idat)
{
  if(idat.Compiling())
  {  
      Word *fbegin;
      string Blook = "runbegin";
      fbegin = idat.IDict()->Address(Blook);
      idat.BuildAddElement(fbegin);
      long ee = idat.BuildLastUsedElement();           
      idat.PushLabeledAD((unsigned long)fbegin, ee);
  }
}

// Function name	: Primitives::L_rununtil
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_rununtil(InterpreterData & idat)
{
      long jb = idat.PopD();   // index to return to
      long sv = idat.PopD();   // test 
      if(sv == 0)
      {
          RSData ar = idat.GetRsv(0);
          ar.SetIndex(jb); 
          idat.SetRsv(ar, 0);
      }
}

// Function name	: Primitives::L_until
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_until(InterpreterData & idat)
{
    if(idat.Compiling())
    {    
      Word *funtil;
      string Ulook = "rununtil";
      int bnd;

      funtil = idat.IDict()->Address(Ulook);
      bnd = idat.PopLabeledAD();
      if(bnd >= 0)
      {
             idat.BuildAddElement((long)bnd);
             idat.BuildAddElement(funtil);
      }
      else
      {
             idat.ShowError(Errors::NO_BEGIN); 
      }
    }
    else
    {
      long jb = idat.PopD();   // index to return to
      long sv = idat.PopD();   // test 
      if(sv == 0)
      {
          RSData ar = idat.GetRsv(0);
          ar.SetIndex(jb); 
          idat.SetRsv(ar, 0);
      }
    }
}

// Function name	: Primitives::L_runwhile
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_runwhile(InterpreterData & idat)
{
     long jb = idat.PopD();   // index of repeat
      long sv = idat.PopD();   // test 
      if(sv == false)
      {
          RSData ar = idat.GetRsv(0);
          ar.SetIndex(jb); 
          idat.SetRsv(ar, 0);
      }
}

// Function name	: Primitives::L_while
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_while(InterpreterData & idat)
{
    if(idat.Compiling())
    {    
      Word *fwhile = idat.IDict()->Address("runwhile");
      int bnd = idat.PeekLabeledAD();

      if(bnd >= 0)
      {
             idat.BuildAddElement((long)bnd);     // for repeat
             idat.BuildAddElement(fwhile);
             long ee = idat.BuildLastUsedElement();           
             idat.PushLabeledAD((unsigned long)fwhile, ee);
      }
      else
      {
             idat.ShowError(Errors::NO_BEGIN); 
      }
    }
    else
    {
      long jb = idat.PopD();   // index of repeat
      long sv = idat.PopD();   // test 
      if(sv == false)
      {
          RSData ar = idat.GetRsv(0);
          ar.SetIndex(jb); 
          idat.SetRsv(ar, 0);
      }
    }
}

// Function name	: Primitives::L_repeat
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_runrepeat(InterpreterData & idat)
{
     unsigned long jb = idat.PopD();   // index to 'begin'
     RSData ar = idat.GetRsv(0);
     ar.SetIndex(jb); 
     idat.SetRsv(ar, 0);
}

// Function name	: Primitives::L_repeat
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_repeat(InterpreterData & idat)
{
    if(idat.Compiling())
    {    
      Word *frepeat = idat.IDict()->Address("runrepeat");
      int whi = idat.PopLabeledAD();
      int bnd = idat.PopLabeledAD();
      
      if(bnd >= 0)
      {
             idat.BuildAddElement((long)bnd);
             idat.BuildAddElement(frepeat);
             unsigned long ee = idat.BuildLastUsedElement();  
             idat.Building()->SetLiteralValue(whi - 1, &ee);
      }
      else
      {
             idat.ShowError(Errors::NO_BEGIN); 
      }
    }
    else
    {
      unsigned long jb = idat.PopD();   // index to 'begin'
      RSData ar = idat.GetRsv(0);
      ar.SetIndex(jb); 
      idat.SetRsv(ar, 0);
    }
}

// Function name	: Primitives::L_again
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_runagain(InterpreterData & idat)
{
     unsigned long jb = idat.PopD();   // index to 'begin'
     RSData ar = idat.GetRsv(0);
     ar.SetIndex(jb); 
     idat.SetRsv(ar, 0);
}

// Function name	: Primitives::L_again
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_again(InterpreterData & idat)
{
    if(idat.Compiling())
    {    
      Word *fagain = idat.IDict()->Address("runagain");
      int bnd = idat.PopLabeledAD();
      
      if(bnd >= 0)
      {
             idat.BuildAddElement((long)bnd);
             idat.BuildAddElement(fagain);
      }
      else
      {
             idat.ShowError(Errors::NO_BEGIN); 
      }
    }
    else
    {
      unsigned long jb = idat.PopD();   // index to 'begin'
      RSData ar = idat.GetRsv(0);
      ar.SetIndex(jb); 
      idat.SetRsv(ar, 0);
    }
}

// Function name	: Primitives::L_questiondup
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_questiondup(InterpreterData & idat)
{
  long aa = idat.PopD();
  if(aa)
  {
    idat.PushD(aa);
    idat.PushD(aa);
  }
  else
  {
    idat.PushD(aa);
  }
}


// Function name	: Primitives::L_dup
// Description	    : ( a -- a a )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_dup(InterpreterData & idat)
{
  long aa = idat.PopD();
  idat.PushD(aa);
  idat.PushD(aa);
}

// Function name	: Primitives::L_swap
// Description	    : ( a b -- b a )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_swap(InterpreterData & idat)
{
  long aa = idat.PopD();
  long bb = idat.PopD();
  idat.PushD(aa);
  idat.PushD(bb);
}

// Function name	: Primitives::L_questionrundo
// Description	    : ( start limit -- )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_runquestiondo(InterpreterData & idat)
{
       long *pind = (long *) idat.PopD();              // get pushed addresses
       long *plim = (long *) idat.PopD();              // either keys of index limit
       long lind = idat.PopD();                        // index of "loop or +loop"
       if((*plim) == 1234567 && (*pind) == 1234567)    // if they are keys first loop
       {
          *pind = idat.PopD();                         // set to index
          *plim = idat.PopD();                         // set to limit 
          if((*pind) == (*plim))                       // if equal we jump to "loop or +loop"
          {                                            
            RSData ar = idat.GetRsv(0);
            Word *wn = ar.Code();
            if(wn->SameWord(lind, "runloop", idat))
            {
               ar.SetIndex((lind - 2));   // loop
            }
            else
            {
               ar.SetIndex((lind - 2));  // +loop
            }
            idat.SetRsv(ar, 0);              
          }
       }
}

// Function name	: Primitives::L_questiondo
// Description	    : ( start limit -- )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_questiondo(InterpreterData & idat)
{
    if(idat.Compiling())                   // compiling ??
    {   
          Word *fqdo;                       // a pointer for us
          string Dlook = "?rundo";             // my name
          fqdo = idat.IDict()->Address(Dlook);  // address of word 'do'
          
          long key1 = (long)1234567;

          idat.BuildAddElement((long)0);   // for index of "loop or +loop"
          idat.BuildAddElement(&key1);     // variable for limit
          idat.BuildAddElement(&key1);     // variable for index
          idat.BuildAddElement(fqdo);
          long ee = idat.BuildLastUsedElement();           
          idat.PushLabeledAD((unsigned long)fqdo, ee);
    }
    else  // not compiling
    {
       long *pind = (long *) idat.PopD();              // get pushed addresses
       long *plim = (long *) idat.PopD();              // either keys of index limit
       long lind = idat.PopD();                        // index of "loop or +loop"
       if((*plim) == 1234567 && (*pind) == 1234567)    // if they are keys first loop
       {
          *pind = idat.PopD();                         // set to index
          *plim = idat.PopD();                         // set to limit 
          if((*pind) == (*plim))                       // if equal we jump to "loop or +loop"
          {                                            
            RSData ar = idat.GetRsv(0);
            Word *wn = ar.Code();
            if(wn->SameWord(lind, "loop", idat))
            {
               ar.SetIndex((lind - 2));   // loop
            }
            else
            {
               ar.SetIndex((lind - 2));  // +loop
            }
            idat.SetRsv(ar, 0);              
          }
       }
    }
}


// Function name	: Primitives::L_rundo
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_rundo(InterpreterData & idat)
{
       long *pind = (long *) idat.PopD();              // get pushed addresses
       long *plim = (long *) idat.PopD();              // either keys of index limit
       long qdo = idat.PopD();                         // for ?do index of "loop or +loop"
       if((*plim) == 1234567 && (*pind) == 1234567)   // if they are keys first loop
       {
          *pind = idat.PopD();                         // set to index
          *plim = idat.PopD();                         // set to limit                 
       }
}

// Function name	: Primitives::L_do
// Description	    : ( start limit -- )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_do(InterpreterData & idat) throw(...)
{
    if(idat.CompilingNI())                   // compiling ??
    {   
          Word *fdo;                       // a pointer for us
          string Dlook = "rundo";             // runtime do
          fdo = idat.IDict()->Address(Dlook);  // address of word 'do'
          
          long key1 = 1234567l;

          idat.BuildAddElement(0l);   // for ?do index of "loop or +loop"
          idat.BuildAddElement(&key1);     // variable for limit
          idat.BuildAddElement(&key1);     // variable for index
          idat.BuildAddElement(fdo);
          long ee = idat.BuildLastUsedElement();
          idat.PushLabeledAD((unsigned long) fdo, ee);
    }
    else  // not compiling
    {
       long *pind = (long *) idat.PopD();              // get pushed addresses
       long *plim = (long *) idat.PopD();              // either keys of index limit
       long qdo = idat.PopD();                         // for ?do index of "loop or +loop"
       try
       {
            if((*plim) == 1234567 && (*pind) == 1234567)   // if they are keys first loop
            {
                *pind = idat.PopD();                         // set to index
                *plim = idat.PopD();                         // set to limit                 
            }
       }
       catch(...)
       {
         idat.FatalError();
         idat.ShowError(Errors::LOOP_INDEX_INVALID);
         throw;
       }
    }
}


// Function name	: Primitives::L_runloop
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_runloop(InterpreterData & idat)
{
      int doindex = (int ) idat.PopD();               // index of 'do' on stack 
      RSData ar = idat.GetRsv(0);              // get return stack entry (it called me)
      Word *calling = ar.Code();               // get the address of the word that called

      unsigned long lim = 1001;                    
      unsigned long ind = 1001;

      calling->LiteralValue((doindex - 1), &ind);  
      calling->LiteralValue((doindex - 2), &lim);


      ind++;                                     // increment index
      if(ind < lim)                              // loop not done ??
      { 
         calling->SetLiteralValue((doindex - 1), &ind); 
         ar.SetIndex(doindex);                       // set up jump back to do index
         idat.SetRsv(ar, 0);                         // reset return stack
      }
      else
      {
          unsigned long key1 = (long)1234567;
          calling->SetLiteralValue((doindex - 1), &key1); 
          calling->SetLiteralValue((doindex - 2), &key1); 
      }
}


// Function name	: Primitives::L_loop
// Description	    : ( 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_loop(InterpreterData & idat)
{
    if(idat.CompilingNI())                          // compiling ?
    {   
          Word *floop;                            // a pointer for me (loop)
          int ido;                          
          unsigned long ee;
          string Llook = "runloop";                  // my name
          floop = idat.IDict()->Address(Llook);   // set to address of word loop

          Parser * par = idat.IParser();

          ido = idat.PopLabeledAD();
          if(ido >= 3)  // do uses ii, ii+1, ii+2 ii+3
          {
             idat.BuildAddElement((long)ido);
             idat.BuildAddElement(floop);
             ee = idat.BuildLastUsedElement();
             idat.Building()->SetLiteralValue((ido - 3), &ee);   // set the value to loop's index
          }
          else   // 'do' not found ??
          {
             idat.ShowError(Errors::NO_DO); 
          }
    }
    else   // not compiling
    {
      int doindex = (int ) idat.PopD();               // index of 'do' on stack 
      RSData ar = idat.GetRsv(0);              // get return stack entry (it called me)
      Word *calling = ar.Code();               // get the address of the word that called

      unsigned long lim = 1001;                    
      unsigned long ind = 1001;

      calling->LiteralValue((doindex - 1), &ind);  
      calling->LiteralValue((doindex - 2), &lim);


      ind++;                                     // increment index
      if(ind < lim)                              // loop not done ??
      { 
         calling->SetLiteralValue((doindex - 1), &ind); 
         ar.SetIndex(doindex);                       // set up jump back to do index
         idat.SetRsv(ar, 0);                         // reset return stack
      }
      else
      {
          unsigned long key1 = (long)1234567;
          calling->SetLiteralValue((doindex - 1), &key1); 
          calling->SetLiteralValue((doindex - 2), &key1); 
      }
    }
}

// Function name	: Primitives::L_runplusloop
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_runplusloop(InterpreterData & idat)
{
        int doindex = (int ) idat.PopD();        // index of 'do' on stack 
        
        RSData ar = idat.GetRsv(0);              // get return stack entry (it called me)
        Word *calling = ar.Code();               // get the address of the word with +lopp in it
        
        long incr = 0;
        long lim = 1001;                    
        long ind = 1001 ;
        
        calling->LiteralValue((doindex - 1), (unsigned long *)&ind);  
        calling->LiteralValue((doindex - 2), (unsigned long *)&lim);
        
        unsigned long tst = (ind < lim);
        
        if(ind != lim)                         // ?do no execute check
        { 
            incr = idat.PopD();                 // get increment
            if(ind < lim)
            {
                ind += incr;  
                tst = (ind < lim);
            }
            else
            {
                ind += incr;
                tst = (ind >= lim);
            }
        }
        // increment index
        
        
        if(tst)                          // loop not done ??
        { 
            calling->SetLiteralValue((doindex - 1), (unsigned long *)&ind); 
            ar.SetIndex(doindex);                       // set up jump back to do index
            idat.SetRsv(ar, 0);                         // reset return stack
        }
        else
        {
            unsigned long key1 = (long)1234567;
            calling->SetLiteralValue((doindex - 1), &key1); 
            calling->SetLiteralValue((doindex - 2), &key1); 
        }
}

// Function name	: Primitives::L_plusloop
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_plusloop(InterpreterData & idat)
{
    if(idat.Compiling())                          // compiling ?
    {   
        
        Word *fploop;                            // a pointer for me (+loop)
        int ido;                          
        unsigned long ee;
        string Llook = "+runloop";                  // my name
        
        fploop = idat.IDict()->Address(Llook);   // set to address of word +loop
        
        Parser * par = idat.IParser();
        
        ido = idat.PopLabeledAD();              // get the index of do
        if(ido >= 3)  // do uses ii, ii+1, ii+2 ii+3
        {
            idat.BuildAddElement((long)ido);
            idat.BuildAddElement(fploop);
            ee = idat.BuildLastUsedElement();
            idat.Building()->SetLiteralValue((ido - 3), &ee);
        }
        else   // 'do' not found ??
        {
            idat.ShowError(Errors::NO_DO); 
        }
    }
    else   // not compiling
    {
        int doindex = (int ) idat.PopD();        // index of 'do' on stack 
        
        RSData ar = idat.GetRsv(0);              // get return stack entry (it called me)
        Word *calling = ar.Code();               // get the address of the word with +lopp in it
        
        long incr = 0;
        long lim = 1001;                    
        long ind = 1001 ;
        
        calling->LiteralValue((doindex - 1), (unsigned long *)&ind);  
        calling->LiteralValue((doindex - 2), (unsigned long *)&lim);
        
        unsigned long tst = (ind < lim);
        
        if(ind != lim)                         // ?do no execute check
        { 
            incr = idat.PopD();                 // get increment
            if(ind < lim)
            {
                ind += incr;  
                tst = (ind < lim);
            }
            else
            {
                ind += incr;
                tst = (ind >= lim);
            }
        }
        // increment index
        
        
        if(tst)                          // loop not done ??
        { 
            calling->SetLiteralValue((doindex - 1), (unsigned long *)&ind); 
            ar.SetIndex(doindex);                       // set up jump back to do index
            idat.SetRsv(ar, 0);                         // reset return stack
        }
        else
        {
            unsigned long key1 = (long)1234567;
            calling->SetLiteralValue((doindex - 1), &key1); 
            calling->SetLiteralValue((doindex - 2), &key1); 
        }
    }
}

// Function name	: Primitives::L_drop
// Description	    : ( n --- )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_drop(InterpreterData & idat)
{
   long aa = idat.PopD();
}

// Function name	: Primitives::L_over
// Description	    : ( n1 n2 --- n1 n2 n1 )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_over(InterpreterData & idat)
{
   long aa = idat.PopD();  // n2
   long bb = idat.PopD();  // n1
   idat.PushD(bb);         // n1
   idat.PushD(aa);         // n2
   idat.PushD(bb);         // n1
}

// Function name	: Primitives::L_rot
// Description	    : ( n1 n2 n3 --- n2 n3 n1 )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_rot(InterpreterData & idat)
{
   long aa = idat.PopD();  // a
   long bb = idat.PopD();  // b
   long cc = idat.PopD();  // c
   idat.PushD(bb);
   idat.PushD(aa);
   idat.PushD(cc);
}

// Function name	: Primitives::L_reverserot
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_reverserot(InterpreterData & idat)
{
   long aa = idat.PopD();  // n3
   long bb = idat.PopD();  // n2
   long cc = idat.PopD();  // n1
   idat.PushD(aa);
   idat.PushD(cc);
   idat.PushD(bb);
}

// Function name	: Primitives::L_multiply
// Description	    : ( a b --- a*b )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_multiply(InterpreterData & idat)
{
   long aa = idat.PopD();  
   long bb = idat.PopD(); 
   long cc = aa * bb;
   idat.PushD(cc);
}

// Function name	: Primitives::L_starslash
// Description	    : ( n1 n2 n3 -- [n1*n2]/n3 )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_starslash(InterpreterData & idat)
{
   __int64 aa = (__int64) idat.PopD();  // n3
   __int64 bb = (__int64) idat.PopD();  // n2
   __int64 cc = (__int64) idat.PopD();  // n1
   __int64 dd = (bb * cc) / aa;
   idat.PushD((long)dd);
}

// Function name	: Primitives::L_starslashmod
// Description	    : ( n1 n2 n3 -- [n1*n2]%n3 [n1*n2]/n3 )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_starslashmod(InterpreterData & idat)
{
   __int64 aa = (__int64) idat.PopD();  // n3
   __int64 bb = (__int64) idat.PopD();  // n2
   __int64 cc = (__int64) idat.PopD();  // n1
   __int64 dd = (bb * cc) / aa;
   __int64 ee = (bb * cc) % aa;
   idat.PushD((long)ee);
   idat.PushD((long)dd);
}

// Function name	: Primitives::L_slashmod
// Description	    : ( n1 n2 -- n3 n4 )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_slashmod(InterpreterData & idat)
{
   long n2 = idat.PopD();  // n2
   long n1 = idat.PopD();  // n1
   long n4 = n1 / n2;
   long n3 = n1 % n2;
   idat.PushD(n3);
   idat.PushD(n4);
}

// Function name	: Primitives::L_mod
// Description	    : ( n1 n2 -- n3 n4 )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_mod(InterpreterData & idat)
{
   long n2 = idat.PopD();  // n2
   long n1 = idat.PopD();  // n1
    long n3 = n1 % n2;
   idat.PushD(n3);
}

// Function name	: Primitives::L_divide
// Description	    : ( b a -- b/a )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_divide(InterpreterData & idat)
{
   long aa = idat.PopD();  
   long bb = idat.PopD(); 
   
   if(aa == 0)
   {
     idat.ShowError(Errors::DIVIDEBYZERO);
   }
   else
   {
     long dd = bb / aa;
     idat.PushD(dd);
   }
}

//void Primitives::L_greaternumber(InterpreterData & idat)
//{
//   long slen = idat.PopD();  
//   char *cstr = (char *)idat.PopD(); 
//   unsigned long rn = (idat.PopD()) * (*idat.Base());
//   __int64 _atoi64( const char *string ); 

//   char * eptr;
//   unsigned long uu;

//   uu = strtoul(cstr, &eptr, (*idat.Base())); 
//   rn += uu;
//   idat.PushD(rn);
//   idat.PushD(eptr);
//   idat.PushD(slen - (eptr - cstr));
//}

void Primitives::L_greaternumber(InterpreterData & idat)
{
   unsigned long slen = idat.PopD();  
   char *cstr = (char *)idat.PopD(); 
   __int64 rn = Pop64(idat); 
   __int64 bs = ( __int64) (*idat.Base());
   char ss[2];
   __int64 vv = (__int64) 0l;

   rn = rn * bs;
   int rr;
   int kk = strlen(cstr);
   char *eptr;
   unsigned long uu;

   for(int ii = 0;ii < slen;ii++)
   {
     ss[0] = cstr[ii];
     ss[1] = 0;
     rr = ii;
     uu = strtoul(ss, &eptr, (*idat.Base())); 
     if(uu == 0 && ss[0] != '0')
     {
       break; 
     }
     else
     {
       if(ii > 0)
       {
          vv = (vv * bs) + ((__int64) uu);
       }
       else
       {
          vv = ((__int64) uu);
       }
     }
   }

   rn += vv;
   Push64(rn, idat);
   idat.PushD(&cstr[rr]);
   idat.PushD((slen - rr - 1));
}


// Function name	: Primitives::L_hex
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_hex(InterpreterData & idat)
{
   (*idat.Base()) = 16;
}


// Function name	: Primitives::L_octal
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_octal(InterpreterData & idat)
{
   (*idat.Base()) = 8;
}

void Primitives::L_decimal(InterpreterData & idat)
{
   (*idat.Base()) = 10;
}


// Function name	: Primitives::L_base
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_base(InterpreterData & idat)
{
   idat.PushD((long)idat.Base());
}

// Function name	: Primitives::L_constant
// Description	    : defines a constant
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_constant(InterpreterData & idat)
{
  string awrd;
  Parser * par = idat.IParser();
  char * wrd;

  if(idat.Compiling())
  {
     // the word constant is only interpreted "to compile a constant'
     // then the name it compiles is a new forth word
      idat.ShowError(Errors::ILLEGALDEFINING);
      return;
  }

 if((wrd = par->NextWord()) != NULL)
 {
    awrd = wrd;
    if(idat.IDict()->Exists(awrd) == -1)  // word does not exist
    {
         if(!par->AllDigits(wrd))  // word is not a number
         {
           idat.BuildWithName(awrd);
           
           unsigned long aa = idat.PopD();  
           idat.BuildAddElement((unsigned long) aa);
           idat.BuildFinishWord();
         }
         else
         {
            // trying to name a word with a number error
            idat.ShowError(Errors::IS_NUMBER);
         }
    }
    else
     {
        // word already exists error
        idat.ShowError(Errors::WORD_EXISTS, awrd);
     }
 } 
 else
 {
      // buffer end reached
      idat.ShowError(Errors::BUFFER_END);
 }
}


// Function name	: Primitives::L_variable
// Description	    : defines a variable
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_variable(InterpreterData & idat)
{
  string awrd;
  awrd.reserve(120);
  Parser * par = idat.IParser();
  char * wrd;

  if(idat.Compiling())
  {
     // the word variable is only interpreted "to compile a variable'
     // then the name it compiles is a new forth word
      idat.ShowError(Errors::ILLEGALDEFINING);
      return;
  }

 if((wrd = par->NextWord()) != NULL)
 {
    awrd = wrd;
    if(idat.IDict()->Exists(awrd) == -1)  // word does not exist
    {
         if(!par->AllDigits(wrd))  // word is not a number
         {
           idat.BuildWithName(awrd);
           
           long aa = idat.PopD();  
           idat.BuildAddElement(&aa);           // put long in new AddressV element
           idat.BuildFinishWord();
         }
         else
         {
            // trying to name a word with a number error
            idat.ShowError(Errors::IS_NUMBER);
         }
    }
    else
     {
        // word already exists error
        idat.ShowError(Errors::WORD_EXISTS, awrd);
     }
 } 
 else
 {
      // buffer end reached
      idat.ShowError(Errors::BUFFER_END);
 }
}

// -------------------------class methods------------------

void Primitives::L_EnclosedByte(InterpreterData & idat)
{
    string awrd;
    awrd.reserve(120);
    Parser * par = idat.IParser();
    char * wrd;
    
    if(idat.Compiling())
    {
        // the word variable is only interpreted "to compile a class'
        // then the name it compiles is a new forth word
        idat.ShowError(Errors::ILLEGALDEFINING);
        return;
    }
    
    if((wrd = par->NextWord()) != NULL)
    {
        awrd = wrd;
        if(idat.IDict()->Exists(awrd) == -1)  // word does not exist
        {
            if(!par->AllDigits(wrd))  // word is not a number
            {
                ClassDescription * cd = idat.ClassDSCR()->CompilingWhat(); 
                if(cd != NULL)
                {
                    ClassData * dptr = new ClassData(awrd, 1, cd, 1, NULL);
                    if(cd->AddData(*dptr) == false)
                    {
                        // error data exists with name
                         idat.ShowError(Errors::MEMBER_EXISTS);
                    }
                    delete dptr;
                }
                else
                {
                    // error not compiling class
                    idat.ShowError(Errors::NO_CLASS_EXISTS);
                }
            }
            else
            {
                // error method name expected
                // trying to name a word with a number error
                idat.ShowError(Errors::IS_NUMBER);
            }
        }
        else
        {
            // error word exists
            // word already exists error
            idat.ShowError(Errors::WORD_EXISTS, awrd);
        }
    }
    else
    {
        // buffer end reached
        idat.ShowError(Errors::BUFFER_END);
    }
}


// Function name	: Primitives::L_EnclosedBytes
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_EnclosedBytes(InterpreterData & idat)
{
    string awrd;
    awrd.reserve(120);
    Parser * par = idat.IParser();
    char * wrd;
    
    if(idat.Compiling())
    {
        // the word variable is only interpreted "to compile a class'
        // then the name it compiles is a new forth word
        idat.ShowError(Errors::ILLEGALDEFINING);
        return;
    }
    
    if((wrd = par->NextWord()) != NULL)
    {
        awrd = wrd;
        if(idat.IDict()->Exists(awrd) == -1)  // word does not exist
        {
            if(!par->AllDigits(wrd))  // word is not a number
            {
                ClassDescription * cd = idat.ClassDSCR()->CompilingWhat(); 
                if(cd != NULL)
                {
                    unsigned long nn = idat.PopD();
                    ClassData * dptr = new ClassData(awrd, 1, cd, nn, NULL);
                    if(cd->AddData(*dptr) == false)
                    {
                        // error data exists with name
                         idat.ShowError(Errors::MEMBER_EXISTS);
                    }
                    delete dptr;
                }
                else
                {
                    // error not compiling class
                    idat.ShowError(Errors::NO_CLASS_EXISTS);
                }
            }
            else
            {
                // error method name expected
                // trying to name a word with a number error
                idat.ShowError(Errors::IS_NUMBER);
            }
        }
        else
        {
            // error word exists
            // word already exists error
            idat.ShowError(Errors::WORD_EXISTS, awrd);
        }
    }
    else
    {
        // buffer end reached
        idat.ShowError(Errors::BUFFER_END);
    }
}


// Function name	: Primitives::L_EnclosedWord
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_EnclosedWord(InterpreterData & idat)
{
    string awrd;
    awrd.reserve(120);
    Parser * par = idat.IParser();
    char * wrd;
    
    if(idat.Compiling())
    {
        // the word variable is only interpreted "to compile a class'
        // then the name it compiles is a new forth word
        idat.ShowError(Errors::ILLEGALDEFINING);
        return;
    }
    
    if((wrd = par->NextWord()) != NULL)
    {
        awrd = wrd;
        if(idat.IDict()->Exists(awrd) == -1)  // word does not exist
        {
            if(!par->AllDigits(wrd))  // word is not a number
            {
                ClassDescription * cd = idat.ClassDSCR()->CompilingWhat(); 
                if(cd != NULL)
                {
                    ClassData * dptr = new ClassData(awrd, 2, cd, 1, NULL);
                    if(cd->AddData(*dptr) == false)
                    {
                        // error data exists with name
                         idat.ShowError(Errors::MEMBER_EXISTS);
                    }
                    delete dptr;
                }
                else
                {
                    idat.DebugTrace(" >>>NULL returned from idat.ClassDSCR()->CompilingWhat()");
                    // error not compiling class
                    idat.ShowError(Errors::NO_CLASS_EXISTS);
                }
            }
            else
            {
                // error method name expected
                // trying to name a word with a number error
                idat.ShowError(Errors::IS_NUMBER);
            }
        }
        else
        {
            // error word exists
            // word already exists error
            idat.ShowError(Errors::WORD_EXISTS, awrd);
        }
    }
    else
    {
        // buffer end reached
        idat.ShowError(Errors::BUFFER_END);
    }
}


// Function name	: Primitives::L_EnclosedWords
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_EnclosedWords(InterpreterData & idat)
{
    string awrd;
    awrd.reserve(120);
    Parser * par = idat.IParser();
    char * wrd;
    
    if(idat.Compiling())
    {
        // the word variable is only interpreted "to compile a class'
        // then the name it compiles is a new forth word
        idat.ShowError(Errors::ILLEGALDEFINING);
        return;
    }
    
    if((wrd = par->NextWord()) != NULL)
    {
        awrd = wrd;
        if(idat.IDict()->Exists(awrd) == -1)  // word does not exist
        {
            if(!par->AllDigits(wrd))  // word is not a number
            {
                ClassDescription * cd = idat.ClassDSCR()->CompilingWhat(); 
                if(cd != NULL)
                {
                    unsigned long nn = idat.PopD();
                    ClassData * dptr = new ClassData(awrd, 2, cd, nn, NULL);
                    if(cd->AddData(*dptr) == false)
                    {
                        // error data exists with name
                         idat.ShowError(Errors::MEMBER_EXISTS);
                    }
                    delete dptr;
                }
                else
                {
                    // error not compiling class
                    idat.ShowError(Errors::NO_CLASS_EXISTS);
                }
            }
            else
            {
                // error method name expected
                // trying to name a word with a number error
                idat.ShowError(Errors::IS_NUMBER);
            }
        }
        else
        {
            // error word exists
            // word already exists error
            idat.ShowError(Errors::WORD_EXISTS, awrd);
        }
    }
    else
    {
        // buffer end reached
        idat.ShowError(Errors::BUFFER_END);
    }
}



// Function name	: Primitives::L_EnclosedDWord
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_EnclosedDWord(InterpreterData & idat)
{
    string awrd;
    awrd.reserve(120);
    Parser * par = idat.IParser();
    char * wrd;
    ClassDescription * cd;
    
    if(idat.Compiling())
    {
        // the word variable is only interpreted "to compile a class'
        // then the name it compiles is a new forth word
        idat.ShowError(Errors::ILLEGALDEFINING);
        return;
    }
    
    if((wrd = par->NextWord()) != NULL)
    {
        awrd = wrd;
        if(idat.IDict()->Exists(awrd) == -1)  // word does not exist
        {
            if(!par->AllDigits(wrd))  // word is not a number
            {

                idat.DebugTrace(" >>>Getting idat.ClassDSCR()->CompilingWhat() in [dword]");
                cd = idat.ClassDSCR()->CompilingWhat(); 
                if(cd != NULL)
                {
                    ClassData * dptr = new ClassData(awrd, 4, cd, 1, NULL);
                    if(cd->AddData(*dptr) == false)
                    {
                        // error data exists with name
                         idat.ShowError(Errors::MEMBER_EXISTS);
                    }
                }
                else
                {
                    idat.DebugTrace(" >>>NULL from idat.ClassDSCR()->CompilingWhat() in [dword]");
                    // error not compiling class
                    idat.ShowError(Errors::NO_CLASS_EXISTS);
                }
            }
            else
            {
                // error method name expected
                // trying to name a word with a number error
                idat.ShowError(Errors::IS_NUMBER);
            }
        }
        else
        {
            // error word exists
            // word already exists error
            idat.ShowError(Errors::WORD_EXISTS, awrd);
        }
    }
    else
    {
        // buffer end reached
        idat.ShowError(Errors::BUFFER_END);
    }
}


// Function name	: Primitives::L_EnclosedDWords
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_EnclosedDWords(InterpreterData & idat)
{
    string awrd;
    awrd.reserve(120);
    Parser * par = idat.IParser();
    char * wrd;
    
    if(idat.Compiling())
    {
        // the word variable is only interpreted "to compile a class'
        // then the name it compiles is a new forth word
        idat.ShowError(Errors::ILLEGALDEFINING);
        return;
    }
    
    if((wrd = par->NextWord()) != NULL)
    {
        awrd = wrd;
        if(idat.IDict()->Exists(awrd) == -1)  // word does not exist
        {
            if(!par->AllDigits(wrd))  // word is not a number
            {
                ClassDescription * cd = idat.ClassDSCR()->CompilingWhat(); 
                if(cd != NULL)
                {
                    unsigned long nn = idat.PopD();
                    ClassData * dptr = new ClassData(awrd, 4, cd, nn, NULL);
                    if(cd->AddData(*dptr) == false)
                    {
                        // error data exists with name
                         idat.ShowError(Errors::MEMBER_EXISTS);
                    }
                    delete dptr;
                }
                else
                {
                    // error not compiling class
                    idat.ShowError(Errors::NO_CLASS_EXISTS);
                }
            }
            else
            {
                // error method name expected
                // trying to name a word with a number error
                idat.ShowError(Errors::IS_NUMBER);
            }
        }
        else
        {
            // error word exists
            // word already exists error
            idat.ShowError(Errors::WORD_EXISTS, awrd);
        }
    }
    else
    {
        // buffer end reached
        idat.ShowError(Errors::BUFFER_END);
    }
}


// Function name	: Primitives::L_EnclosedPointer
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_EnclosedPointer(InterpreterData & idat)
{
    string awrd;
    awrd.reserve(120);
    Parser * par = idat.IParser();
    char * wrd;
    
    if(idat.Compiling())
    {
        // the word variable is only interpreted "to compile a class'
        // then the name it compiles is a new forth word
        idat.ShowError(Errors::ILLEGALDEFINING);
        return;
    }
    
    if((wrd = par->NextWord()) != NULL)
    {
        awrd = wrd;
        if(idat.IDict()->Exists(awrd) == -1)  // word does not exist
        {
            if(!par->AllDigits(wrd))  // word is not a number
            {
                ClassDescription * cd = idat.ClassDSCR()->CompilingWhat(); 
                if(cd != NULL)
                {
                    ClassData * dptr = new ClassData(awrd, sizeof(long *), cd, 1, NULL);
                    if(cd->AddData(*dptr) == false)
                    {
                        // error data exists with name
                         idat.ShowError(Errors::MEMBER_EXISTS);
                    }
                    delete dptr;
                }
                else
                {
                    // error not compiling class
                    idat.ShowError(Errors::NO_CLASS_EXISTS);
                }
            }
            else
            {
                // error method name expected
                // trying to name a word with a number error
                idat.ShowError(Errors::IS_NUMBER);
            }
        }
        else
        {
            // error word exists
            // word already exists error
            idat.ShowError(Errors::WORD_EXISTS, awrd);
        }
    }
    else
    {
        // buffer end reached
        idat.ShowError(Errors::BUFFER_END);
    }
}


// Function name	: Primitives::L_EnclosedPointers
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_EnclosedPointers(InterpreterData & idat)
{
    string awrd;
    awrd.reserve(120);
    Parser * par = idat.IParser();
    char * wrd;
    
    if(idat.Compiling())
    {
        // the word variable is only interpreted "to compile a class'
        // then the name it compiles is a new forth word
        idat.ShowError(Errors::ILLEGALDEFINING);
        return;
    }
    
    if((wrd = par->NextWord()) != NULL)
    {
        awrd = wrd;
        if(idat.IDict()->Exists(awrd) == -1)  // word does not exist
        {
            if(!par->AllDigits(wrd))  // word is not a number
            {
                ClassDescription * cd = idat.ClassDSCR()->CompilingWhat(); 
                if(cd != NULL)
                {
                    unsigned long nn = idat.PopD();
                    ClassData * dptr = new ClassData(awrd, sizeof(long *), cd, nn, NULL);
                    if(cd->AddData(*dptr) == false)
                    {
                        // error data exists with name
                         idat.ShowError(Errors::MEMBER_EXISTS);
                    }
                    delete dptr;
                }
                else
                {
                    // error not compiling class
                    idat.ShowError(Errors::NO_CLASS_EXISTS);
                }
            }
            else
            {
                // error method name expected
                // trying to name a word with a number error
                idat.ShowError(Errors::IS_NUMBER);
            }
        }
        else
        {
            // error word exists
            // word already exists error
            idat.ShowError(Errors::WORD_EXISTS, awrd);
        }
    }
    else
    {
        // buffer end reached
        idat.ShowError(Errors::BUFFER_END);
    }
}


// Function name	: Primitives::L_EnclosedArrays
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_EnclosedArrays(InterpreterData & idat)
{
    string awrd;
    awrd.reserve(120);
    Parser * par = idat.IParser();
    char * wrd;
    
    if(idat.Compiling())
    {
        // the word variable is only interpreted "to compile a class'
        // then the name it compiles is a new forth word
        idat.ShowError(Errors::ILLEGALDEFINING);
        return;
    }
    
    if((wrd = par->NextWord()) != NULL)
    {
        awrd = wrd;
        if(idat.IDict()->Exists(awrd) == -1)  // word does not exist
        {
            if(!par->AllDigits(wrd))  // word is not a number
            {
                ClassDescription * cd = idat.ClassDSCR()->CompilingWhat(); 
                if(cd != NULL)
                {
                    unsigned long nn = idat.PopD();
                    unsigned long si = idat.PopD();
                    ClassData * dptr = new ClassData(awrd, si, cd, nn, NULL);
                    if(cd->AddData(*dptr) == false)
                    {
                        // error data exists with name
                         idat.ShowError(Errors::MEMBER_EXISTS);
                    }
                    delete dptr;
                }
                else
                {
                    // error not compiling class
                    idat.ShowError(Errors::NO_CLASS_EXISTS);
                }
            }
            else
            {
                // error method name expected
                // trying to name a word with a number error
                idat.ShowError(Errors::IS_NUMBER);
            }
        }
        else
        {
            // error word exists
            // word already exists error
            idat.ShowError(Errors::WORD_EXISTS, awrd);
        }
    }
    else
    {
        // buffer end reached
        idat.ShowError(Errors::BUFFER_END);
    }
}


// Function name	: Primitives::L_EnclosedClass
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_EnclosedClass(InterpreterData & idat)
{
    string awrd;
    awrd.reserve(120);
    Parser * par = idat.IParser();
    char * wrd;
    char * cln;
    string acln;
    ClassDescription * datc = NULL;
    ClassDescription * cd = NULL;
    
    if(idat.Compiling())
    {
        // the word variable is only interpreted "to compile a class'
        // then the name it compiles is a new forth word
        idat.ShowError(Errors::ILLEGALDEFINING);
        return;
    }

    if((cln = par->NextWord()) != NULL)
    {
        acln = cln;
        
        if((datc = idat.ClassDSCR()->Find(acln)) == NULL)
        {
           idat.DebugTrace("Found class type in [class]");
           // error no such class type
           idat.ShowError(Errors::NO_CLASS_EXISTS, acln);
           return;
        }
        else
        {
           cd = idat.ClassDSCR()->CompilingWhat(); 
           if(cd == datc)
           {
              // error no such class type
              idat.ShowError(Errors::ILLEGALDEFINING);
              return;
           }
           idat.DebugTrace("Found compiling class type in [class]");
        }
    }
    else
    {
       // buffer end reached
        idat.ShowError(Errors::BUFFER_END);
        return;
    }

    if((wrd = par->NextWord()) != NULL)
    {
        awrd = wrd;
        if(idat.IDict()->Exists(awrd) == -1)  // word does not exist
        {
            if(!par->AllDigits(wrd))  // word is not a number
            {
                if(cd != NULL)
                {
                    ClassData * dptr = new ClassData(awrd, datc->Size(), cd, 1, datc);
                    dptr->SetFlags(ClassData::ClassType);
                    if(cd->AddData(*dptr) == false)
                    {
                        // error data exists with name
                         idat.ShowError(Errors::MEMBER_EXISTS);
                    }
                    char drdr[120];
                    sprintf(drdr, "added [class] %s in %s [%lx] of %s [%lx]", awrd.c_str(), cd->Name().c_str(), cd, datc->Name().c_str(), datc);
                    idat.DebugTrace(drdr);
                    delete dptr;
                    dptr = cd->DataDesc(awrd);
                    if(dptr != NULL)
                    {
                       if(dptr->IsClass())
                       {
                          sprintf(drdr, "found [class] %s [%lx]", dptr->Name().c_str(), dptr);
                       }
                       else
                       {
                          sprintf(drdr, "OBECT NOT CLASS %s [%lx]", dptr->Name().c_str(), dptr);
                       }
                    }
                    else
                    {
                       sprintf(drdr, "NO object from  cd->DataDesc(awrd)");
                    }
                    idat.DebugTrace(drdr);
                }
                else
                {
                    // error not compiling class
                    idat.ShowError(Errors::NO_CLASS_EXISTS);
                }
            }
            else
            {
                // error method name expected
                // trying to name a word with a number error
                idat.ShowError(Errors::IS_NUMBER);
            }
        }
        else
        {
            // error word exists
            // word already exists error
            idat.ShowError(Errors::WORD_EXISTS, awrd);
        }
    }
    else
    {
        // buffer end reached
        idat.ShowError(Errors::BUFFER_END);
    }
}


// Function name	: Primitives::L_EnclosedClasses
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_EnclosedClasses(InterpreterData & idat)
{
    string awrd;
    awrd.reserve(120);
    Parser * par = idat.IParser();
    char * wrd;
    char * cln;
    string acln;
    ClassDescription * datc = NULL;
    ClassDescription * cd = NULL;
    
    if(idat.Compiling())
    {
        // the word variable is only interpreted "to compile a class'
        // then the name it compiles is a new forth word
        idat.ShowError(Errors::ILLEGALDEFINING);
        return;
    }

    if((cln = par->NextWord()) != NULL)
    {
        acln = cln;
        
        if((datc = idat.ClassDSCR()->Find(acln)) == NULL)
        {
           idat.DebugTrace("Found class type in [class]");
           // error no such class type
           idat.ShowError(Errors::NO_CLASS_EXISTS, acln);
           return;
        }
        else
        {
           cd = idat.ClassDSCR()->CompilingWhat(); 
           if(cd == datc)
           {
              // error no such class type
              idat.ShowError(Errors::ILLEGALDEFINING);
              return;
           }
           idat.DebugTrace("Found compiling class type in [class]");
        }
    }
    else
    {
       // buffer end reached
        idat.ShowError(Errors::BUFFER_END);
        return;
    }

    if((wrd = par->NextWord()) != NULL)
    {
        awrd = wrd;
        if(idat.IDict()->Exists(awrd) == -1)  // word does not exist
        {
            if(!par->AllDigits(wrd))  // word is not a number
            {
                if(cd != NULL)
                {
                    unsigned long nn = idat.PopD();
                    ClassData * dptr = new ClassData(awrd, datc->Size(), cd, nn, datc);
                    dptr->SetFlags(ClassData::ClassType);
                    if(cd->AddData(*dptr) == false)
                    {
                        // error data exists with name
                         idat.ShowError(Errors::MEMBER_EXISTS);
                    }
                    char drdr[120];
                    sprintf(drdr, "added [class] %s in %s [%lx] of %s [%lx]", awrd.c_str(), cd->Name().c_str(), cd, datc->Name().c_str(), datc);
                    idat.DebugTrace(drdr);
                    delete dptr;
                    dptr = cd->DataDesc(awrd);
                    if(dptr != NULL)
                    {
                       if(dptr->IsClass())
                       {
                          sprintf(drdr, "found [class] %s [%lx]", dptr->Name().c_str(), dptr);
                       }
                       else
                       {
                          sprintf(drdr, "OBECT NOT CLASS %s [%lx]", dptr->Name().c_str(), dptr);
                       }
                    }
                    else
                    {
                       sprintf(drdr, "NO object from  cd->DataDesc(awrd)");
                    }
                    idat.DebugTrace(drdr);
                }
                else
                {
                    // error not compiling class
                    idat.ShowError(Errors::NO_CLASS_EXISTS);
                }
            }
            else
            {
                // error method name expected
                // trying to name a word with a number error
                idat.ShowError(Errors::IS_NUMBER);
            }
        }
        else
        {
            // error word exists
            // word already exists error
            idat.ShowError(Errors::WORD_EXISTS, awrd);
        }
    }
    else
    {
        // buffer end reached
        idat.ShowError(Errors::BUFFER_END);
    }
}


// Function name	: Primitives::L_MethodSemicolon
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_MethodSemicolon(InterpreterData & idat)
{
    if(idat.Compiling())
    {
        ClassDescription * cd = idat.ClassDSCR()->CompilingWhat(); 
        if(cd->IsMethodCompiling() == true)
        {
            ClassMethod * nm = new ClassMethod(*(idat.Building()), cd);
            delete (idat.Building());
//            nm->AddClassDecription(cd);
            cd->AddMethod(*nm, false);
            delete nm;
            cd->SetMethodCompile(false);
            idat.EndCompile();
        }
        else
        {
            // Show Error 1 Syntax error
            idat.ShowError(Errors::NOT_COMPILING_METHOD);
        }
    }
    else
    {
        // Show Error 1 Syntax error
        idat.ShowError(Errors::SYNTAX_ERROR);
    }
}


// Function name	: Primitives::L_MethodColon
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_MethodColon(InterpreterData & idat)
{
    string awrd;
    awrd.reserve(120);
    Parser * par = idat.IParser();
    char * wrd;
    
    if(idat.Compiling())
    {
        // the word variable is only interpreted "to compile a class'
        // then the name it compiles is a new forth word
        idat.ShowError(Errors::ILLEGALDEFINING);
        return;
    }
    
    if((wrd = par->NextWord()) != NULL)
    {
        awrd = wrd;
//        if(idat.IDict()->Exists(awrd) == -1)  // word does not exist
//        {
            if(!par->AllDigits(wrd))  // word is not a number
            {
                ClassDescription * cd = idat.ClassDSCR()->CompilingWhat(); 
                if(cd != NULL)
                {
                    if(cd->IsMethodCompiling() == false)
                    {
                        idat.DebugTrace("Starting method");
                        cd->SetMethodCompile(true);
                        idat.BuildWithName(awrd);
                        idat.Compile();
                    }
                    else
                    {
                        // error alredy building method
                        idat.ShowError(Errors::COMPILING_METHOD);
                    }
                }
                else
                {
                    // error not compiling class
                    idat.ShowError(Errors::NO_CLASS_EXISTS);
                }
            }
            else
            {
                // error method name expected
                // trying to name a word with a number error
                idat.ShowError(Errors::IS_NUMBER);
            }
//        }
//        else
//        {
            // error word exists
            // word already exists error
//            idat.ShowError(Errors::WORD_EXISTS);
//        }
    }
    else
    {
        // buffer end reached
        idat.ShowError(Errors::BUFFER_END);
    }
}


// Function name	: Primitives::L_This
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_This(InterpreterData & idat)
{
    ClassDescription * aa = NULL;  
    aa = (ClassDescription *) idat.PopD();
    char * bb = aa->ThisFront();
    idat.PushD(((long)bb));
}


// Function name	: Primitives::L_DashRightGreater
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_DashRightGreater(InterpreterData & idat)
{
    string awrd, bwrd;
    awrd.reserve(120);
    Parser * par = idat.IParser();
    char * wrd;

  char * cc = NULL;;
  ClassDescription * aa = NULL;;
  Element *anel = NULL;


  if((wrd = par->NextWord()) != NULL)
   {
       awrd = wrd;
       aa = idat.ClassDSCR()->Find(awrd);
       if(aa == NULL)
       {
          // Show Error 1 Syntax error
         idat.ShowError(Errors::SYNTAX_ERROR);
         return;
       }
  }
  
  if(idat.Compiling())
  {
    if((wrd = par->NextWord()) != NULL)
    {
         awrd = wrd;
         ClassMethod * pcm = aa->MethodDesc(awrd);
         ClassData * pcd = aa->DataDesc(awrd);

         char test1[200];
         sprintf(test1, " class description in '->' = %lx, method = %lx, data = %lx", (void *)aa,
             (void *)pcm, (void *)pcd);
         idat.DebugTrace(test1); 

         if(pcm != NULL)
         {  
             if(pcm->FlagsMatch(ClassMethod::Private) == 0 && pcm->FlagsMatch(ClassMethod::Protected) == 0)
             {
                idat.BuildAddElement(pcm);
             }
             else
             {
                idat.ShowError(Errors::PRIVATE_METHOD);
             }
         }
         else
         {
            if(pcd != NULL)
            {         
               if(pcd->FlagsMatch(ClassData::Private) == 0 && pcm->FlagsMatch(ClassData::Protected) == 0)
               {
                  idat.BuildAddElement(pcd);
               }
               else
               {
                  idat.ShowError(Errors::PRIVATE_MEMBER);
               }
            }
            else
            {              
                // no class member error
                idat.ShowError(Errors::NO_MEMBER_FOUND);
            }
         }
    }
    else
    {
       idat.ShowError(Errors::BUFFER_END);
    }
  }
  else
  {
    if((wrd = par->NextWord()) != NULL)
    {
         awrd = wrd;
         cc = (char *) idat.PopD(); 
 
         ClassMethod * pcm = aa->MethodDesc(awrd);
         ClassData * pcd = aa->DataDesc(awrd);

         char test1[200];
         sprintf(test1, " class description in '->' = %lx, method = %lx, data = %lx", (void *)aa,
             (void *)pcm, (void *)pcd);
         idat.DebugTrace(test1); 

         if(pcm != NULL)
         {       
            idat.PushD((long) cc);
            pcm->Execute(0, idat); 
         } 
         else
         {
            if(pcd != NULL)
            {  
               idat.PushD((long) cc);
               pcd->Resolve(idat);
            }
            else
            {
               // no class member error
                idat.ShowError(Errors::NO_MEMBER_FOUND);
            }
         }
    }
  }
}



// Function name	: Primitives::L_DashDot
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_DashDot(InterpreterData & idat)
{
  string awrd;
  awrd.reserve(120);
  Parser * par = idat.IParser();
  char * wrd;

  char * cc = NULL;;
  ClassDescription * aa = NULL;;
  Element *anel = NULL;
  
  if(idat.Compiling())
  {
    if((wrd = par->NextWord()) != NULL)
    {
         awrd = wrd;
         aa = (ClassDescription *)idat.PopD(); 
         ClassMethod * pcm = aa->MethodDesc(awrd);
         ClassData * pcd = aa->DataDesc(awrd);

         char test1[200];
         sprintf(test1, " class description in L_DashDot = %lx, method = %lx, data = %lx", (void *)aa,
             (void *)pcm, (void *)pcd);
         idat.DebugTrace(test1); 

         if(pcm != NULL)
         {  
             if(pcm->FlagsMatch(ClassMethod::Private) == 0 && pcm->FlagsMatch(ClassMethod::Protected) == 0)
             {
                idat.BuildAddElement(pcm);
             }
             else
             {
                idat.ShowError(Errors::PRIVATE_METHOD);
             }
         }
         else
         {
            if(pcd != NULL)
            {         
               if(pcd->FlagsMatch(ClassData::Private) == 0 && pcm->FlagsMatch(ClassData::Protected) == 0)
               {
                  idat.BuildAddElement(pcd);
               }
               else
               {
                  idat.ShowError(Errors::PRIVATE_MEMBER);
               }
            }
            else
            {              
                // no class member error
                idat.ShowError(Errors::NO_MEMBER_FOUND);
            }
         }
    }
    else
    {
       idat.ShowError(Errors::BUFFER_END);
    }
  }
  else
  {
    if((wrd = par->NextWord()) != NULL)
    {
         awrd = wrd;
         cc = (char *) idat.PopD(); 
         aa = (ClassDescription *)idat.PopD(); 
         ClassMethod * pcm = aa->MethodDesc(awrd);
         ClassData * pcd = aa->DataDesc(awrd);

         char test1[200];
         sprintf(test1, " class description in L_DashDot = %lx, method = %lx, data = %lx", (void *)aa,
             (void *)pcm, (void *)pcd);
         idat.DebugTrace(test1); 

         if(pcm != NULL)
         {       
            idat.PushD((long) cc);
            pcm->Execute(0, idat); 
         } 
         else
         {
            if(pcd != NULL)
            {  
               idat.PushD((long) cc);
               pcd->Resolve(idat);
            }
            else
            {
               // no class member error
                idat.ShowError(Errors::NO_MEMBER_FOUND);
            }
         }
    }
  } 
}


// Function name	: Primitives::L_ExecuteConstructor
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_ExecuteConstructor(InterpreterData & idat)
{
       long Aobj = idat.PopD();   // 'obj
       ClassDescription * cd = (ClassDescription *) idat.PopD();     // 'cd
       cd->CallConstructor((char *)Aobj);
       idat.PushD(((long)cd));
       idat.PushD(Aobj);
}

// Function name	: Primitives::L_DeleteClass
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_DeleteClass(InterpreterData & idat)
{
    void *zz = ((void *) idat.PopD());
    
    int mt = (idat.MManager()).Typeof(zz); 
    if(mt != -1)
    {
        if(mt == MemInstDat::m_Class)
        {
            int mh = (idat.MManager()).Hintof(zz); 
            ClassDescription * cd = (ClassDescription *) mh;
            if(cd != NULL)
            {
                idat.PushD((long)zz);
                cd->CallDestructor();
            }
        }
        (idat.MManager()).DeleteMem(zz, MemInstDat::m_Class);
    }
}

void Primitives::L_NewClass(InterpreterData & idat)
{
  string awrd;
  awrd.reserve(120);
  Parser * par = idat.IParser();
  char * wrd;  

 idat.DebugTrace("In 'new'  L_NewClass"); 

 if((wrd = par->NextWord()) != NULL)
 {
    awrd = wrd;
    ClassDescription * cd = NULL; 
    if((cd = idat.ClassDSCR()->Find(awrd)) != NULL)
    {
       void * vp = idat.MManager().AllocateType(MemInstDat::m_Class, cd->Size());
       cd->CallConstructor((char *)vp);
       idat.PushD((long)vp);
    }
    else
    {
       idat.ShowError(Errors::NO_CLASS_EXISTS);
    }
 }
 else
 {
      // buffer end reached
      idat.ShowError(Errors::BUFFER_END);   
 }
}


// Function name	: Primitives::L_MakeClassCompileTest
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_MakeClassCompileTest(InterpreterData & idat)
{
    if(idat.Compiling())
    {
       long Aobj = idat.PopD();   // 'obj
       long cd = idat.PopD();     // 'cd
       idat.BuildAddElement(Aobj);        // put 'obj in new element
       idat.PushD(cd);                    // push cd for '-:' use
    }
}

// makes a named instance of a class
// The class name when executed will put it's class descripter and class object on the stack
void Primitives::L_MakeClass(InterpreterData & idat)
{
  string awrd;
  awrd.reserve(120);
  Parser * par = idat.IParser();
  char * wrd;

  if(idat.Compiling())
  {
      idat.DebugTrace("Still compiling word type??"); 
      idat.ShowError(Errors::ILLEGALDEFINING);
      return;
  }

 idat.DebugTrace("In L_MakeClass"); 

 if((wrd = par->NextWord()) != NULL)
 {
    awrd = wrd;
    if(idat.IDict()->Exists(awrd) == -1)  // word does not exist
    {
         if(!par->AllDigits(wrd))  // word is not a number
         {
           long aa = idat.PopD(); 
           ClassDescription * cd = (ClassDescription *) aa;
           char test1[200];
           sprintf(test1, "cd = %lx in L_MakeClass", (void *)cd);
           idat.DebugTrace(test1); 

           if(cd->Compiling() == false)
           {
              idat.BuildWithName(awrd);
              idat.BuildAddElement(aa);            // put long in new element
              idat.DebugTrace("class descriptor added"); 
              void * vp = idat.MManager().AllocateType(MemInstDat::m_Class, cd->Size());
              idat.BuildAddElement((long)vp);
              sprintf(test1, "%s instance created at %lx", cd->Name().c_str(), (char *)vp);
              idat.DebugTrace(test1);
              cd->CallConstructor((char *)vp);

//              Element *cpel = new Element(L_ExecuteConstructor);
//              idat.BuildAddElement((*cpel));
//              idat.DebugTrace("Added class constructor call ");
//              delete cpel;  
              Element *pel = new Element(&Primitives::L_MakeClassCompileTest);
              idat.BuildAddElement((*pel));
              idat.Building()->SetFlags(idat.ExecuteCompile);  // set new named instance so immediate
              idat.BuildFinishWord();
              delete pel;
           }
           else
           {
              idat.DebugTrace("Still compiling class type??"); 
              idat.ShowError(Errors::ILLEGALDEFINING);
           }
         }
         else
         {
            // trying to name a word with a number error
            idat.ShowError(Errors::IS_NUMBER);
         }
    }
    else
     {
        // word already exists error
        idat.ShowError(Errors::WORD_EXISTS, awrd);
     }
 } 
 else
 {
      // buffer end reached
      idat.ShowError(Errors::BUFFER_END);
 }
}

// Function name	: Primitives::L_class
// Description	    : starts a class
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_class(InterpreterData & idat)
{
  string awrd;
  awrd.reserve(120);
  Parser * par = idat.IParser();
  char * wrd;

  if(idat.Compiling())
  {
     // the word variable is only interpreted "to compile a class'
     // then the name it compiles is a new forth word
      idat.ShowError(Errors::ILLEGALDEFINING);
      return;
  }

 if((wrd = par->NextWord()) != NULL)
 {
    awrd = wrd;
    if(idat.IDict()->Exists(awrd) == -1)  // word does not exist
    {
         if(!par->AllDigits(wrd))  // word is not a number
         {
               ClassDescription * cd = NULL; 
               if(idat.ClassDSCR()->Find(awrd, cd) == false)
               {
                  cd = new ClassDescription(awrd, &idat);
                  idat.ClassDSCR()->AddDescription((*cd));
                  delete cd;
                  
                  cd = idat.ClassDSCR()->CompilingWhat();
                  if(cd == NULL)
                  {
                     idat.DebugTrace(">>>false returned from iidat.ClassDSCR()->CompilingWhat() in class:");
                  }
                  else
                  {
                    idat.DebugTrace(">>>Non-NULL returned from idat.ClassDSCR()->CompilingWhat() in class:");
//                  ClassMethod * mp = new ClassMethod();
//                  mp->SetFlags(idat.Private);
                    idat.BuildWithName(awrd);
                    idat.BuildAddElement((long)cd);
                    Element *pel = new Element(&Primitives::L_MakeClass);
                    idat.BuildAddElement((*pel));
                    idat.Building()->SetFlags(idat.ExecuteCompile);  // set new class type so immediate
                    idat.BuildFinishWord();
                    delete pel;
                  }
                }
               else
               {
                // class already exists error
                   idat.ShowError(Errors::CLASS_EXISTS);
               }
         }
         else
         {
            // trying to name a word with a number error
            idat.ShowError(Errors::IS_NUMBER);
         }
    }
    else
     {
        // word already exists error
        idat.ShowError(Errors::WORD_EXISTS, awrd);
     }
 } 
 else
 {
      // buffer end reached
      idat.ShowError(Errors::BUFFER_END);
 }
}


// Function name	: Primitives::L_endclass
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_endclass(InterpreterData & idat)
{
  ClassDescription * cd = idat.ClassDSCR()->CompilingWhat(); 
  if(cd != NULL)
  {
    idat.ClassDSCR()->Compiled();
  }
  else
  {
      // buffer end reached
      idat.ShowError(Errors::NO_CLASS_EXISTS);
  }
}


// Function name	: Primitives::L_privatecolon
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_privatecolon(InterpreterData & idat)
{
  ClassDescription * cd = idat.ClassDSCR()->CompilingWhat(); 
  if(cd != NULL)
  {
    cd->SetPrivateMode(true);
  }
  else
  {
      // buffer end reached
      idat.ShowError(Errors::NO_CLASS_EXISTS);
  }
}


// Function name	: Primitives::L_publiccolon
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_publiccolon(InterpreterData & idat)
{
  ClassDescription * cd = idat.ClassDSCR()->CompilingWhat(); 
  if(cd != NULL)
  {
    cd->SetPrivateMode(false);
  }
  else
  {
      // buffer end reached
      idat.ShowError(Errors::NO_CLASS_EXISTS);
  }
}


// Function name	: Primitives::L_protectedcolon
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_protectedcolon(InterpreterData & idat)
{
  ClassDescription * cd = idat.ClassDSCR()->CompilingWhat(); 
  if(cd != NULL)
  {
    cd->SetPrivateMode(false);
  }
  else
  {
      // buffer end reached
      idat.ShowError(Errors::NO_CLASS_EXISTS);
  }
}

// := class inheritance

// Function name	: Primitives::L_ColonEqual
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_ColonEqual(InterpreterData & idat)
{
    string awrd;
    awrd.reserve(120);
    Parser * par = idat.IParser();
    char * wrd;
    
    if(idat.Compiling())
    {
        // the word := is only interpreted "to compile a class'
        idat.ShowError(Errors::ILLEGALDEFINING);
        return;
    }
    
    if((wrd = par->NextWord()) != NULL)
    {
        awrd = wrd;
        if(idat.IDict()->Exists(awrd) != -1)  // word does exist
        {
           ClassDescription * cd = NULL;
           if((cd = idat.ClassDSCR()->CompilingWhat()) != NULL)
           {
               if(cd->IsPrivateMode())
               {
                   cd->Inherit(awrd, ClassDescription::CompilePrivate);
               }
               else
               {
                   if(cd->IsProtectedMode())
                   {
                       cd->Inherit(awrd, ClassDescription::CompileProtected); 
                   }
                   else
                   {
                       cd->Inherit(awrd, ClassDescription::CompilePublic); 
                   }
               }
           }
           else
           {
              idat.ShowError(Errors::NO_CLASS_EXISTS);
           }
        }
        else
        {
            idat.ShowError(Errors::NO_CLASS_EXISTS);
        }
    }
    else
    {
        // buffer end reached
        idat.ShowError(Errors::BUFFER_END);
    }
}



// Function name	: Primitives::L_DecompileClass
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_DecompileClass(InterpreterData & idat)
{
  string awrd;
  awrd.reserve(120);
  Parser * par = idat.IParser();
  char * wrd;

  ClassDescription * cd = NULL; 
  
    if((wrd = par->NextWord()) != NULL)
    {
      awrd = wrd;
      if((cd = idat.ClassDSCR()->Find(awrd)))
      {
         string txt;
         txt.reserve(4000);
         cd->Decompile(txt, idat);
         idat.Out() += txt;
         idat.WriteOut();
         idat.LineOut();
      }
    }
    else
    {
      idat.ShowError(Errors::BUFFER_END);
    }
}

// end class words

// Function name	: Primitives::L_bracketcharbracket
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_bracketcharbracket(InterpreterData & idat)
{
  string awrd;
  awrd.reserve(120);
  Parser * par = idat.IParser();
  char * wrd;

  if(idat.Compiling())
  { 
     if((wrd = par->NextWord()) != NULL)
     {
          unsigned long nn = (long) wrd[0];
          idat.BuildAddElement(nn);  
     } 
     else
     {
          // buffer end reached
          idat.ShowError(Errors::BUFFER_END);
     }
  }
  else
  {      
      idat.ShowError(Errors::ONLY_COMPILED);
  }
}

// Function name	: Primitives::L_char
// Description	    : starts a class
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_char(InterpreterData & idat)
{
    string awrd;
    awrd.reserve(120);
    Parser * par = idat.IParser();
    char * wrd;
    
    if((wrd = par->NextWord()) != NULL)
    {
        awrd = wrd;
        if(!par->AllDigits(wrd))  // word is not a number
        {
            unsigned long nn = (unsigned long) wrd[0];
            idat.PushD(nn);
            idat.DebugTrace(wrd);
        }
        else
        {
            // trying to name a word with a number error
            idat.ShowError(Errors::IS_NUMBER);
        }
    } 
    else
    {
        // buffer end reached
        idat.ShowError(Errors::BUFFER_END);
    }
}

// Function name	: Primitives::L_store
// Description	    : ( &long n -- ) 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_store(InterpreterData & idat)
{
   long *paa = (long *) idat.PopD();
   long aa = idat.PopD();
   *paa = aa;
}

// Function name	: Primitives::L_twostore
// Description	    : ( &long n -- ) 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_twostore(InterpreterData & idat)
{
   long *paa = (long *) idat.PopD();
   long x2 = idat.PopD();
   long x1 = idat.PopD();
   *paa = x2;
   *(paa +1) = x1;
}


// Function name	: Primitives::L_twofetch
// Description	    : ( &long n -- ) 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_twofetch(InterpreterData & idat)
{
   long *paa = (long *) idat.PopD();
   long x2 = *paa;
   long x1 = *(paa+1);
   idat.PushD(x1);
   idat.PushD(x2);
}


// Function name	: Primitives::L_plusstore
// Description	    : ( &long n -- )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_plusstore(InterpreterData & idat)
{
   long *paa = (long *) idat.PopD();
   long aa = idat.PopD();
   *paa += aa;
}


// Function name	: Primitives::L_fetch
// Description	    : ( &long -- n )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_fetch(InterpreterData & idat)
{
   long *paa = (long *) idat.PopD();
   long aa = *paa;
   idat.PushD(aa);
}


// Function name	: Primitives::L_oneplus
// Description	    : ( n -- n+1 )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_oneplus(InterpreterData & idat)
{
   long aa = idat.PopD();
   aa++;
   idat.PushD(aa);
}


// Function name	: Primitives::L_oneminus
// Description	    : ( n -- n-1 )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_oneminus(InterpreterData & idat)
{
   long aa = idat.PopD();
   aa--;
   idat.PushD(aa);
}

// Function name	: Primitives::L_twoplus
// Description	    : ( n -- n+2 )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_twoplus(InterpreterData & idat)
{
   long aa = idat.PopD();
   aa += 2;
   idat.PushD(aa);
}

// Function name	: Primitives::L_twominus
// Description	    : ( n -- n-2 )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_twominus(InterpreterData & idat)
{
   long aa = idat.PopD();
   aa -= 2;
   idat.PushD(aa);
}

// Function name	: Primitives::L_twotimes
// Description	    : ( n -- 2*n )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_twotimes(InterpreterData & idat)
{
   long aa = idat.PopD();
   aa = aa + aa;
   idat.PushD(aa);
}

// Function name	: Primitives::L_twoslash
// Description	    : ( n -- n/2 )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_twoslash(InterpreterData & idat)
{
   long aa = idat.PopD();
   aa = (aa >> 1);
   idat.PushD(aa);
}

// Function name	: Primitives::L_abs
// Description	    : ( n -- abs(n) )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_abs(InterpreterData & idat)
{
   long aa = labs(idat.PopD());
   idat.PushD(aa);
}

// Function name	: Primitives::L_and
// Description	    : ( a b -- a & b )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_and(InterpreterData & idat)
{
   long aa = idat.PopD();
   long bb = idat.PopD();
   long cc = (aa & bb);
   idat.PushD(cc);
}

// Function name	: Primitives::L_or
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_or(InterpreterData & idat)
{
   long aa = idat.PopD();
   long bb = idat.PopD();  
   long cc = (aa | bb);
   idat.PushD(cc);
}

// Function name	: Primitives::L_xor
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_xor(InterpreterData & idat)
{
   long aa = idat.PopD();
   long bb = idat.PopD();
   long cc = (aa ^ bb);
   idat.PushD(cc);
}

// Function name	: Primitives::L_not
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_not(InterpreterData & idat)
{
   long aa = ~idat.PopD();
   idat.PushD(aa);
}

// Function name	: Primitives::L_rshift
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_rshift(InterpreterData & idat)
{
   unsigned long sa = idat.PopD();
   unsigned long aa = idat.PopD();
   idat.PushD((aa >> sa));
}

// Function name	: Primitives::L_lshift
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_lshift(InterpreterData & idat)
{
   unsigned long sa = idat.PopD();
   unsigned long aa = idat.PopD();
   idat.PushD((aa << sa));
}

// Function name	: Primitives::L_invert
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_invert(InterpreterData & idat)
{
   unsigned long aa = idat.PopD();
// unsigned long bb = aa ^ ULONG_MAX;
   unsigned long bb = ~aa;
   idat.PushD(bb);
}

void Primitives::L_source(InterpreterData & idat)
{
    char * pp = idat.IParser()->Lastline();
    
    if(pp != NULL)
    {
        char drdr[120];
        sprintf(drdr, "Source Line %s, (source)", pp);
        idat.DebugTrace(drdr);
        idat.PushD(((long)pp));
        idat.PushD(((long)strlen(pp)));   
    }
    else
    {
        idat.DebugTrace("Source Line NULL in source");
        idat.PushD(0l);
        idat.PushD(0l);   
    }
}

void Primitives::L_state(InterpreterData & idat)
{
  long l = (long) idat.State();
  idat.PushD(l);
}

// Function name	: Primitives::L_max
// Description	    : ( a b -- max(a,b) )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_max(InterpreterData & idat)
{
   long aa = idat.PopD();
   long bb = idat.PopD();
   if (aa > bb)
   {
     idat.PushD(aa);
   }
   else
   {
     idat.PushD(bb);
   }
}

// Function name	: Primitives::L_min
// Description	    : ( a b --- min(a,b) )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_min(InterpreterData & idat)
{
   long aa = idat.PopD();
   long bb = idat.PopD();
   if (aa > bb)
   {
     idat.PushD(bb);
   }
   else
   {
     idat.PushD(aa);
   }
}

// Function name	: Primitives::L_lessthan
// Description	    : ( b a -- b < a )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_lessthan(InterpreterData & idat)
{
   long aa = idat.PopD();
   long bb = idat.PopD();
   if (aa > bb)
   {
     idat.PushD(-1l);
   }
   else
   {
     idat.PushD((long)false);
   }
}

// Function name	: Primitives::L_lessthan
// Description	    : ( b a -- b < a )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_ulessthan(InterpreterData & idat)
{
   unsigned long aa = idat.PopD();
   unsigned long bb = idat.PopD();
   if (aa > bb)
   {
     idat.PushD(-1l);
   }
   else
   {
     idat.PushD((long)false);
   }
}

// Function name	: Primitives::L_greaterthan
// Description	    : ( b a -- b > a )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_greaterthan(InterpreterData & idat)
{
   long aa = idat.PopD();
   long bb = idat.PopD();
   if (aa < bb)
   {
     idat.PushD(-1l);
   }
   else
   {
     idat.PushD((long)false);
   }
}


// Function name	: Primitives::L_greaterthanequal
// Description	    : ( b a -- b >= a ) 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_greaterthanequal(InterpreterData & idat)
{
   long aa = idat.PopD();
   long bb = idat.PopD();
   if (aa <= bb)
   {
     idat.PushD(-1l);
   }
   else
   {
     idat.PushD((long)false);
   }
}


// Function name	: Primitives::L_lessthanequal
// Description	    : ( b a --- b <= a )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_lessthanequal(InterpreterData & idat)
{
   long aa = idat.PopD();
   long bb = idat.PopD();
   if (aa >= bb)
   {
     idat.PushD(-1l);
   }
   else
   {
     idat.PushD((long)false);
   }
}


// Function name	: Primitives::L_notequal
// Description	    : ( b a -- b != a )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_notequal(InterpreterData & idat)
{
   long aa = idat.PopD();
   long bb = idat.PopD();
   if (aa != bb)
   {
     idat.PushD(-1l);
   }
   else
   {
     idat.PushD((long)false);
   }
}


// Function name	: Primitives::L_equal
// Description	    : ( b a -- b == a )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_equal(InterpreterData & idat)
{
   long aa = idat.PopD();
   long bb = idat.PopD();
   if (aa == bb)
   {
     idat.PushD(-1l);
   }
   else
   {
     idat.PushD((long)false);
   }
}

// Function name	: Primitives::L_zeroequal
// Description	    : ( a -- a == 0 )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_zeroequal(InterpreterData & idat)
{
   long aa = idat.PopD();

   if (aa == 0)
   {
     idat.PushD(-1l);
   }
   else
   {
     idat.PushD((long)false);
   }
}


// Function name	: Primitives::L_zeroless
// Description	    : ( a -- a < 0 )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_zeroless(InterpreterData & idat)
{
   long aa = idat.PopD();

   if (aa < 0)
   {
     idat.PushD(-1l);
   }
   else
   {
     idat.PushD((long)false);
   }
}


// Function name	: Primitives::L_zeronot
// Description	    : a -- a != 0 )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_zeronot(InterpreterData & idat)
{
   long aa = idat.PopD();

   if (aa != 0)
   {
     idat.PushD(-1l);
   }
   else
   {
     idat.PushD((long)false);
   }
}


// Function name	: Primitives::L_zerogreater
// Description	    : ( a --- a > 0 )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_zerogreater(InterpreterData & idat)
{
   long aa = idat.PopD();

   if (aa > 0)
   {
     idat.PushD(true);
   }
   else
   {
     idat.PushD((long)false);
   }
}


// Function name	: Primitives::L_negate
// Description	    : ( n --- -n )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_negate(InterpreterData & idat)
{
   long aa = -idat.PopD();

   idat.PushD(aa);
}



// Function name	: Primitives::L_stringcopy
// Description	    : ( &STLstringt &STLstrings -- &STLstringt )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_stringcopy(InterpreterData & idat)
{
   string *ss = (string *) ((void *) idat.PopD());
   string *tt = (string *) ((void *) idat.PopD());
   (*tt) = (*ss);

   idat.PushD((long) tt);
}

// Function name	: Primitives::L_stringplus
// Description	    : ( &STLstr1 &STLstr2 -- &STLstr1 )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_stringplus(InterpreterData & idat)
{
   string *ss = (string *) ((void *) idat.PopD());
   string *tt = (string *) ((void *) idat.PopD());
   (*tt) += (*ss);

   idat.PushD((unsigned long) tt);
}


// Function name	: Primitives::L_stringequal
// Description	    : ( &STLstr1 &STLstr2 --- flag )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_stringequal(InterpreterData & idat)
{
   string *ss = (string *) ((void *) idat.PopD());
   string *tt = (string *) ((void *) idat.PopD());

   if (*ss == *tt)
   {
     idat.PushD(true);
   }
   else
   {
     idat.PushD((long)false);
   }
}


// Function name	: Primitives::L_substring
// Description	    : ( &STLstr1 &STLstr2 start length --- &STLstr1)
//                    puts the substring starting at start of length into str2
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_substring(InterpreterData & idat)
{
   long length = idat.PopD();
   long start = idat.PopD();
   string *tt = (string *) ((void *) idat.PopD());
   string *zz = (string *) ((void *) idat.PopD());
   *zz = (*tt).substr(start, length);
   idat.PushD((unsigned long) zz);
}

// Function name	: Primitives::L_stringvariable
// Description	    : Defines a STL string 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_stringvariable(InterpreterData & idat)
{
  string awrd;
  Parser * par = idat.IParser();
  char * wrd;

  if(idat.Compiling())
  {
     // this word is only interpreted "to compile a variable'
     // then the name it compiles is a new forth word
      idat.ShowError(Errors::ILLEGALDEFINING);
      return;
  }

 if((wrd = par->NextWord()) != NULL)
 {
    awrd = wrd;
    if(idat.IDict()->Exists(awrd) == -1)  // word does not exist
    {
         if(!par->AllDigits(wrd))         // word is not a number
         {
           idat.BuildWithName(awrd);
           
//           string *tt = (string *) ((void *) idat.PopD()); 
           string *tt = reinterpret_cast<string *>(idat.PopD());
           if(tt == NULL)
           {
             idat.ShowError(Errors::BAD_POINTER); 
           }
           string *ss = new string();
           ss->reserve(200);
           *ss = *tt;
           idat.BuildAddElement(ss);
           idat.BuildFinishWord();
         }
         else
         {
            // trying to name a word with a number error
            idat.ShowError(Errors::IS_NUMBER);
         }
    }
    else
     {
        // word already exists error
        idat.ShowError(Errors::WORD_EXISTS, awrd);
     }
 } 
 else
 {
      // buffer end reached
      idat.ShowError(Errors::BUFFER_END);
 }
}

// Function name	: Primitives::L_stringtocstr
// Description	    : ( &STLstring &char -- )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_stringtocstr(InterpreterData & idat)
{
   char *zz = (char *) ((void *) idat.PopD());
   string *tt = (string *) ((void *) idat.PopD());
   string ss = *tt;
   strcpy(zz, ss.c_str());
   zz[ss.size()] = 0;
}


// Function name	: Primitives::cstrtostring
// Description	    : ( &char &STLstring -- )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_cstrtostring(InterpreterData & idat)
{
   string *tt = (string *) ((void *) idat.PopD());
   char *zz = (char *) ((void *) idat.PopD());
   (*tt) = zz;
}

// Function name	: Primitives::cstrtostring
// Description	    : ( &char &STLstring -- )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_chararraylen(InterpreterData & idat)
{
   char *zz = (char *) ((void *) idat.PopD());
   long len = 0l;
   try
   {
     len = strlen(zz);
   }
   catch(...)
   {

   }
   idat.PushD(len);
}


void Primitives::L_chararray(InterpreterData & idat)
{
  string awrd;
  Parser * par = idat.IParser();
  char * wrd;

  if(idat.Compiling())
  {
     // the word variable is only interpreted "to compile a variable'
     // then the name it compiles is a new forth word
      idat.ShowError(Errors::ILLEGALDEFINING);
      return;
  }

 if((wrd = par->NextWord()) != NULL)
 {
    awrd = wrd;
    if(idat.IDict()->Exists(awrd) == -1)  // word does not exist
    {
         if(!par->AllDigits(wrd))         // word is not a number
         {
           idat.BuildWithName(awrd);
           
           long aa = idat.PopD();      // get size
           void *cc = idat.MManager().AllocateType(MemInstDat::m_CharArray, (aa+1));
           char *nc = (char *) cc; 
           memset(nc, 0, aa+1);
           idat.BuildAddElement((long) cc);   // put pointer as long into new element
           idat.BuildFinishWord();
         }
         else
         {
            // trying to name a word with a number error
             idat.ShowError(Errors::IS_NUMBER);
         }
    }
    else
     {
        // word already exists error
        idat.ShowError(Errors::WORD_EXISTS, awrd);
     }
 } 
 else
 {
      // buffer end reached
     idat.ShowError(Errors::BUFFER_END);
 }
}

// Function name	: Primitives::L_deletechararray
// Description	    : ( &char[] --- flag )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_deletechararray(InterpreterData & idat)
{
   void *zz = ((void *) idat.PopD());
   long rv = (idat.MManager()).DeleteMem(zz, MemInstDat::m_CharArray);
   idat.PushD(rv);
}

// Function name	: Primitives::L_cstore
// Description	    : ( addr c -- )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_cstore(InterpreterData & idat)
{
   char *buf = (char *) ((void *) idat.PopD());
   char cc = (char) (idat.PopD());
   *buf = cc;
}

// Function name	: Primitives::L_cfetch
// Description	    : ( addr -- c )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_cfetch(InterpreterData & idat)
{
   char *buf = (char *) ((void *) idat.PopD());
   char cc = *buf;
   idat.PushD((long) cc);
}

// Function name	: Primitives::L_cstore
// Description	    : ( addr c -- )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_wstore(InterpreterData & idat)
{
   WORD *buf = (WORD *) ((void *) idat.PopD());
   WORD cc = (WORD) (idat.PopD());
   *buf = cc;
}

// Function name	: Primitives::L_cfetch
// Description	    : ( addr -- c )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_wfetch(InterpreterData & idat)
{
   WORD *buf = (WORD *) ((void *) idat.PopD());
   WORD cc = *buf;
   idat.PushD((long) cc);
}

// Function name	: Primitives::L_greaterin
// Description	    : (  -- adr )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_greaterin(InterpreterData & idat)
{

  idat.PushD(idat.pIN());
}

// Function name	: Primitives::L_type
// Description	    : ( addr len -- )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_type(InterpreterData & idat)
{
   long aa = ( idat.PopD());
   aa = __min(aa, 8000);
   char *buf = (char *) ((void *) idat.PopD());
   char *cc = new char[aa+1];
   strncpy(cc,buf,aa);
   cc[aa] = 0;
   string co = cc;
   idat.Out() += co.c_str();
   idat.WriteOut();
   delete cc;
}

// Function name	: Primitives::L_count
// Description	    : ( addr -- addr count )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_count(InterpreterData & idat)
{
   char *buf = NULL;
   char *buf2 = NULL;;
   long len = 0;

   buf = (char *) idat.PopD();

   if(buf != NULL)
   {  
      buf2 = buf + sizeof(long);
      len = *((long *)buf);
   }

   len = __min(len, 64000l);
   idat.PushD((unsigned long) buf2);
   idat.PushD(len);
}

void Primitives::L_find(InterpreterData & idat)
{
    string anam;
    anam.reserve(120);
    Parser * par = idat.IParser();
    char * cntnam = NULL;
    char * wrd = NULL;
    char * nam;
    Word * ww = NULL;

    cntnam = (char * ) idat.PopD();
    
    if(cntnam != NULL)
    {
      nam = (cntnam + sizeof(long));

      if((ww = idat.IDict()->Address(nam)) != NULL)
      {
         idat.PushD((long)ww);
         if(ww->FlagsMatch(idat.ExecuteCompile))
         {
           idat.PushD(1);
         }
         else
         {
           idat.PushD(-1);
         }
      }
      else
      {
         idat.PushD((long)cntnam);
         idat.PushD(0l);
      }  
    }
}


// Function name	: Primitives::L_traceon
// Description	    : turn on tracing
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_traceon(InterpreterData & idat)
{
  idat.TraceOn(); 
  string ts = " \n----------TRACE-TURNED_ON----------\n ";
  idat.TraceOut(ts);
}

// Function name	: Primitives::L_traceoff
// Description	    : turn off tracing
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_traceoff(InterpreterData & idat)
{
  string ts = " \n----------DONE_TRACE----------\n ";
  idat.TraceOut(ts);  
  idat.TraceOff();
}

// Function name	: Primitives::L_addtrace
// Description	    : add string to tracing output
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_addtrace(InterpreterData & idat)
{
  if(idat.Tracing())
  {
    string *ss = (string *) ((void *) idat.PopD());
    string ts = " >>>  ";
    ts += (*ss);
    idat.TraceOut(ts);  
  }
}


// Function name	: Primitives::L_stackdepth
// Description	    : ( --- data-stack-depth)
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_stackdepth(InterpreterData & idat)
{
  idat.PushD((long)idat.SizeD());
}

// need char strcpy, strncopy
// memcpy, memset


// Function name	: Primitives::L_strcpy
// Description	    : ( &c_str1 &c_str2 -- )
// Return type		: void 
void Primitives::L_strcpy(InterpreterData & idat)
{
   char *str2 = (char *) ((void *) idat.PopD());
   char *str1 = (char *) ((void *) idat.PopD());
   strcpy(str1, str2);
}

// Function name	: Primitives::L_strncpy
// Description	    : ( &c_str1 &c_str2 n -- )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_strncpy(InterpreterData & idat)
{
   long nn = idat.PopD();
   char *str2 = (char *) ((void *) idat.PopD());
   char *str1 = (char *) ((void *) idat.PopD());
   strncpy(str1, str2, nn);
}

// Function name	: Primitives::L_strncpy
// Description	    : ( &c_str1 &c_str2 n -- )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_memcpy(InterpreterData & idat)
{
   long nn = idat.PopD();
   char *str2 = (char *) ((void *) idat.PopD());
   char *str1 = (char *) ((void *) idat.PopD());
   memcpy(str1, str2, nn);
}

// Function name	: Primitives::L_memset
// Description	    : ( &c_str1 char nn -- )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_memset(InterpreterData & idat)
{
  long nn = idat.PopD();
  long cc = idat.PopD();
  char *buf = (char *) ((void *) idat.PopD());
  memset(buf,cc,nn);
}

// structure name
//     n char name
//     n array-of char name
//
// end-structure

void Primitives::L_createinstance(InterpreterData & idat)
{
  long aa = idat.PopD();
  void *cc = idat.MManager().AllocateType(MemInstDat::m_CharArray, (aa+1));
  char *nc = (char *) cc; 
  memset(nc, 0, aa+1);
  idat.PushD((long )cc);
}

// structures
void Primitives::L_structure(InterpreterData & idat)
{
  string awrd;
  Parser * par = idat.IParser();
  char * wrd;

  if(idat.Compiling())
  {
     // the word structure is only interpreted "to create a structure type'
     // it compiles is a new forth word
      idat.ShowError(Errors::ILLEGALDEFINING);
      return;
  }

 if((wrd = par->NextWord()) != NULL)
 {
    awrd = wrd;
    if(idat.IDict()->Exists(awrd) == -1)  // word does not exist
    {
         if(!par->AllDigits(wrd))  // word is not a number
         {
           idat.BuildWithName(awrd);
//           long nn = idat.PopD();
           idat.BuildAddElement((long) 0);   // space for final size
           idat.BuildFinishWord();
           Word * ww = idat.IDict()->Address(awrd);
           idat.PushAD((long)ww);  // use auillary stack for new word's address
         }
         else
         {
            // trying to name a word with a number error
            idat.ShowError(Errors::IS_NUMBER);
         }
    }
    else
     {
        // word already exists error
        idat.ShowError(Errors::WORD_EXISTS, awrd);
     }
 } 
 else
 {
      // buffer end reached
     idat.ShowError(Errors::BUFFER_END);
 }
}


// Function name	: Primitives::L_Nchar
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_Nchar(InterpreterData & idat)
{
  string awrd;
  Parser * par = idat.IParser();
  char * wrd;

  if(idat.Compiling())
  {
     // the word structure is only interpreted "to create a structure type'
     // it compiles is a new forth word
      idat.ShowError(Errors::ILLEGALDEFINING);
      return;
  }

 if((wrd = par->NextWord()) != NULL)
 {
    awrd = wrd;
    if(idat.IDict()->Exists(awrd) == -1)  // word does not exist
    {
         if(!par->AllDigits(wrd))  // word is not a number
         {
           // start offset word
           idat.BuildWithName(awrd);
           // get stucture word address
           Word * ww = ((Word *) idat.PopAD()); // get structure word from aux stack
           // get current offset into structure
           unsigned long bb;
           ww->LiteralValue(0, &bb);
           // get length of this char[]
           int ns = idat.PopD();
           // add length to offset word
           idat.BuildAddElement((long) bb);   // space for offset
           // get address of word '+'
           string act = "+";
           Word * add = idat.IDict()->Address(act);
           // add call to '+'
           idat.BuildAddElement(add);
           // finish offset word
           idat.BuildFinishWord();
           // set new size of structure to char[] + old size
           bb += ns;
           ww->SetLiteralValue(0, &bb);
           // put back structure word address
           idat.PushAD((long)ww);         
         }
         else
         {
             // trying to name a word with a number error
             idat.ShowError(Errors::IS_NUMBER);
         }
    }
    else
     {
        // word already exists error
        idat.ShowError(Errors::WORD_EXISTS, awrd);
     }
 } 
 else
 {
      // buffer end reached
     idat.ShowError(Errors::BUFFER_END);
 }
}


// Function name	: Primitives::L_Nshort
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_Nshort(InterpreterData & idat)
{
  string awrd;
  Parser * par = idat.IParser();
  char * wrd;

  if(idat.Compiling())
  {
     // the word structure is only interpreted "to create a structure type'
     // it compiles is a new forth word
      idat.ShowError(Errors::ILLEGALDEFINING);
      return;
  }

 if((wrd = par->NextWord()) != NULL)
 {
    awrd = wrd;
    if(idat.IDict()->Exists(awrd) == -1)  // word does not exist
    {
         if(!par->AllDigits(wrd))  // word is not a number
         {
           // start offset word
           idat.BuildWithName(awrd);
           // get stucture word address
           Word * ww = ((Word *) idat.PopAD()); // get structure word from aux stack
           // get current offset into structure
           unsigned long bb;
           ww->LiteralValue(0, &bb);
           // get length of this short
           int ns = sizeof(short);
           // add size to new offset word
           idat.BuildAddElement((long) bb);   
           // get address of word '+'
           string act = "+";
           Word * add = idat.IDict()->Address(act);
           // add call to '+'
           idat.BuildAddElement(add);
           // finish offset word
           idat.BuildFinishWord();
           // set new size of structure to char[] + old size
           bb += ns;
           ww->SetLiteralValue(0, &bb);
           // put back structure word address
           idat.PushAD((long)ww);         
         }
         else
         {
             // trying to name a word with a number error
             idat.ShowError(Errors::IS_NUMBER);
         }
    }
    else
     {
        // word already exists error
        idat.ShowError(Errors::WORD_EXISTS, awrd);
     }
 } 
 else
 {
      // buffer end reached
     idat.ShowError(Errors::BUFFER_END);
 }
}


// Function name	: Primitives::L_Nlong
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_Nlong(InterpreterData & idat)
{
  string awrd;
  Parser * par = idat.IParser();
  char * wrd;

  if(idat.Compiling())
  {
     // the word structure is only interpreted "to create a structure type'
     // it compiles is a new forth word
      idat.ShowError(Errors::ILLEGALDEFINING);
      return;
  }

 if((wrd = par->NextWord()) != NULL)
 {
    awrd = wrd;
    if(idat.IDict()->Exists(awrd) == -1)  // word does not exist
    {
         if(!par->AllDigits(wrd))  // word is not a number
         {
           // start offset word
           idat.BuildWithName(awrd);
           // get stucture word address
           Word * ww = ((Word *) idat.PopAD()); // get structure word from aux stack
           // get current offset into structure
           unsigned long bb;
           ww->LiteralValue(0, &bb);
           // get length of this long
           int ns = sizeof(long);
           // add size to new offset word
           idat.BuildAddElement((long) bb);   
           // get address of word '+'
           string act = "+";
           Word * add = idat.IDict()->Address(act);
           // add call to '+'
           idat.BuildAddElement(add);
           // finish offset word
           idat.BuildFinishWord();
           // set new size of structure to sizeof(long) + old size
           bb += ns;
           ww->SetLiteralValue(0, &bb);
           // put back structure word address
           idat.PushAD((long)ww);         
         }
         else
         {
             // trying to name a word with a number error
             idat.ShowError(Errors::IS_NUMBER);
         }
    }
    else
     {
        // word already exists error
        idat.ShowError(Errors::WORD_EXISTS, awrd);
     }
 } 
 else
 {
      // buffer end reached
     idat.ShowError(Errors::BUFFER_END);
 }
}

// Function name	: Primitives::L_Narraylong
// Description	    : creates an indexed structure array offset word
//                    ( number-longs --- )
//                    new word's stack diagram:
//                    ( &struct index --- offset )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_Narraylong(InterpreterData & idat)
{
  string awrd;
  Parser * par = idat.IParser();
  char * wrd;

  if(idat.Compiling())
  {
     // the word structure is only interpreted "to create a structure type'
     // it compiles is a new forth word
      idat.ShowError(Errors::ILLEGALDEFINING);
      return;
  }

 if((wrd = par->NextWord()) != NULL)
 {
    awrd = wrd;
    if(idat.IDict()->Exists(awrd) == -1)  // word does not exist
    {
         if(!par->AllDigits(wrd))  // word is not a number
         {
           string act;
           // start offset word
           idat.BuildWithName(awrd);
           // get stucture word address
           Word * ww = ((Word *) idat.PopAD());   // get structure word from aux stack
           // get current offset into structure
           unsigned long bb;
           ww->LiteralValue(0, &bb);
           // get number of longs in the array
           int nl = idat.PopD();
           // get length of array
           int ns = sizeof(long) * nl;                   
           idat.BuildAddElement((long) sizeof(long));    // will push size
           act = "*";
           Word * mul = idat.IDict()->Address(act);      
           // add call to '*'
           idat.BuildAddElement(mul);                    // will call *
           // add starting offset to new offset word
           idat.BuildAddElement((long) bb);              // will push offset
           // get address of word '+'                    
           act = "+";
           Word * add = idat.IDict()->Address(act);
           // add call to '+'
           idat.BuildAddElement(add);                    // will call +
           // add 2nd call to '+'
           idat.BuildAddElement(add);                    // will call +
           // finish offset word
           idat.BuildFinishWord();
           // set new size of structure to sizeof(long) + old size
           bb += ns;
           ww->SetLiteralValue(0, &bb);
           // put back structure word address
           idat.PushAD((long)ww);         
         }
         else
         {
             // trying to name a word with a number error
             idat.ShowError(Errors::IS_NUMBER);
         }
    }
    else
     {
        // word already exists error
        idat.ShowError(Errors::WORD_EXISTS, awrd);
     }
 } 
 else
 {
      // buffer end reached
     idat.ShowError(Errors::BUFFER_END);
 }
}


// Function name	: Primitives::L_Narrayshort
// Description	    : creates an indexed structure array offset word
//                    ( number-shorts --- )
//                    new word's stack diagram:
//                    ( &struct index --- offset )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_Narrayshort(InterpreterData & idat)
{
  string awrd;
  Parser * par = idat.IParser();
  char * wrd;

  if(idat.Compiling())
  {
     // the word structure is only interpreted "to create a structure type'
     // it compiles is a new forth word
      idat.ShowError(Errors::ILLEGALDEFINING);
      return;
  }

 if((wrd = par->NextWord()) != NULL)
 {
    awrd = wrd;
    if(idat.IDict()->Exists(awrd) == -1)  // word does not exist
    {
         if(!par->AllDigits(wrd))  // word is not a number
         {
           string act;
           // start offset word
           idat.BuildWithName(awrd);
           // get stucture word address
           Word * ww = ((Word *) idat.PopAD());   // get structure word from aux stack
           // get current offset into structure
           unsigned long bb;
           ww->LiteralValue(0, &bb);
           // get number of longs in the array
           int nl = idat.PopD();
           // get length of array
           int ns = sizeof(short) * nl;
           idat.BuildAddElement((long) sizeof(short));
           act = "*";
           Word * mul = idat.IDict()->Address(act);
           // add call to '*'
           idat.BuildAddElement(mul);
           // add starting offset to new offset word
           idat.BuildAddElement((long) bb);
           // get address of word '+'
           act = "+";
           Word * add = idat.IDict()->Address(act);
           // add call to '+'
           idat.BuildAddElement(add);
           // add 2nd call to '+'
           idat.BuildAddElement(add);                    // will call +
           // finish offset word
           idat.BuildFinishWord();
           // set new size of structure to sizeof(long) + old size
           bb += ns;
           ww->SetLiteralValue(0, &bb);
           // put back structure word address
           idat.PushAD((long)ww);         
         }
         else
         {
             // trying to name a word with a number error
             idat.ShowError(Errors::IS_NUMBER);
         }
    }
    else
     {
        // word already exists error
        idat.ShowError(Errors::WORD_EXISTS, awrd);
     }
 } 
 else
 {
      // buffer end reached
     idat.ShowError(Errors::BUFFER_END);
 }
}


// Function name	: Primitives::L_Narrayobjects
// Description	    : creates an indexed structure array offset word
//                    ( number-objs obj-size -- )
//                    new word's stack diagram:
//                    ( &struct index --- offset )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_Narrayobjects(InterpreterData & idat)
{
  string awrd;
  Parser * par = idat.IParser();
  char * wrd;

  if(idat.Compiling())
  {
     // the word structure is only interpreted "to create a structure type'
     // it compiles is a new forth word
      idat.ShowError(Errors::ILLEGALDEFINING);
      return;
  }

 if((wrd = par->NextWord()) != NULL)
 {
    awrd = wrd;
    if(idat.IDict()->Exists(awrd) == -1)  // word does not exist
    {
         if(!par->AllDigits(wrd))  // word is not a number
         {
           string act;
           // start offset word
           idat.BuildWithName(awrd);
           // get stucture word address
           Word * ww = ((Word *) idat.PopAD());   // get structure word from aux stack
           // get current offset into structure
           unsigned long bb;
           ww->LiteralValue(0, &bb);
           // get size of one char[]
           int sa = idat.PopD();
           // get number of char[] in the array[][]
           int nl = idat.PopD();
           // get length of array
           int ns = sa * nl;
           // set size of one char[]
           idat.BuildAddElement((long) sa);
           act = "*";
           Word * mul = idat.IDict()->Address(act);
           // add call to '*'
           idat.BuildAddElement(mul);
           // add starting offset to new offset word
           idat.BuildAddElement((long) bb);
           // get address of word '+'
           act = "+";
           Word * add = idat.IDict()->Address(act);
           // add call to '+'
           idat.BuildAddElement(add);
           // add 2nd call to '+'
           idat.BuildAddElement(add);                    // will call +
           // finish offset word
           idat.BuildFinishWord();
           // set new size of structure to sizeof(long) + old size
           bb += ns;
           ww->SetLiteralValue(0, &bb);
           // put back structure word address
           idat.PushAD((long)ww);         
         }
         else
         {
             // trying to name a word with a number error
             idat.ShowError(Errors::IS_NUMBER);
         }
    }
    else
     {
        // word already exists error
        idat.ShowError(Errors::WORD_EXISTS, awrd);
     }
 } 
 else
 {
      // buffer end reached
     idat.ShowError(Errors::BUFFER_END);
 }
}

// Function name	: Primitives::L_endstructure
// Description	    : cleans up after building structure
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_endstructure(InterpreterData & idat)
{
  Word * ww = ((Word *) idat.PopAD());   // get structure word from aux stack
  // done
}

// Function name	: Primitives::L_runiinloop
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_runiinloop(InterpreterData & idat)
{
      int doindex = (int ) idat.PopD();        // index of 'do' on stack 
      RSData ar = idat.GetRsv(0);              // get return stack entry (it called me)
      Word *calling = ar.Code();               // get the address of the word that called
              
      unsigned long ind = 1001 ;
      calling->LiteralValue((doindex - 1), &ind);
      idat.PushD(ind);
}

// Function name	: Primitives::L_iinloop
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_iinloop(InterpreterData & idat)
{
    if(idat.CompilingNI())                       // compiling ?
    {                                     
          int ido = idat.FindNthLabeledAD("rundo", "?rundo", 1);
          
          if(ido >= 3)  // do uses 4 positions 
          {
             Word *fi = idat.IDict()->Address("runi");       // set to address of word i
             assert(fi != NULL);
             idat.BuildAddElement((long)ido);
             idat.BuildAddElement(fi);
          }
          else   // 'do' not found ??
          {
             idat.ShowError(Errors::NO_DO); 
          }
    }
    else   // not compiling
    {
      int doindex = (int ) idat.PopD();        // index of 'do' on stack 
      RSData ar = idat.GetRsv(0);              // get return stack entry (it called me)
      Word *calling = ar.Code();               // get the address of the word that called
              
      unsigned long ind = 1001 ;
      calling->LiteralValue((doindex - 1), &ind);
      idat.PushD(ind);
    }
}

// Function name	: Primitives::L_runjinloop
// Description	    : ( -- j )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_runjinloop(InterpreterData & idat)
{
      int doindex = (int ) idat.PopD();               // index of 'do' on stack 
      RSData ar = idat.GetRsv(0);              // get return stack entry (it called me)
      Word *calling = ar.Code();               // get the address of the word that called
              
      unsigned long ind = 1001;
      calling->LiteralValue((doindex - 1), &ind);
      idat.PushD(ind);
}

// Function name	: Primitives::L_jinloop
// Description	    : ( -- j )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_jinloop(InterpreterData & idat)
{
    if(idat.Compiling())                       // compiling ?
    {   
          int ido = idat.FindNthLabeledAD("rundo", "?rundo", 2);
          
          if(ido >= 3)  // do uses 4 positions 
          {
             Word *fj = idat.IDict()->Address("runj");    // set to address of word j
             assert(fj != NULL);
             idat.BuildAddElement((long)ido);
             idat.BuildAddElement(fj);
          }
          else   // 'do' not found ??
          {
             idat.ShowError(Errors::NO_DO); 
          }
    }
    else   // not compiling
    {
      int doindex = (int ) idat.PopD();               // index of 'do' on stack 
      RSData ar = idat.GetRsv(0);              // get return stack entry (it called me)
      Word *calling = ar.Code();               // get the address of the word that called
              
      unsigned long ind = 1001;
      calling->LiteralValue((doindex - 1), &ind);
      idat.PushD(ind);
    }
}


// Function name	: Primitives::L_runleave
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_runleave(InterpreterData & idat)
{
      int doindex = (int ) idat.PopD();        // index of 'do' on stack 
      RSData ar = idat.GetRsv(0);              // get return stack entry (it called me)
      Word *calling = ar.Code();               // get the address of the word that called
              
      unsigned long loopind = 1001;
      calling->LiteralValue((doindex - 3), &loopind);  // get location in word of 'loop'
      unsigned long lim = 1001 ;
      calling->LiteralValue((doindex - 2), &lim); 
      calling->SetLiteralValue((doindex - 1), &lim);   // set loop index to limit

      if(calling->SameWord(loopind, "loop", idat))
      {
          ar.SetIndex((loopind  - 2));   // loop
      }
      else
      {
          ar.SetIndex((loopind  - 2));  // +loop
      }                     
      idat.SetRsv(ar, 0);   
}

// Function name	: Primitives::L_leave
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_leave(InterpreterData & idat)
{
    if(idat.Compiling())                       // compiling ?
    {   
          int ido = idat.FindNthLabeledAD("?rundo", "rundo", 1);

          if(ido >= 3)  // do uses 4 positions 
          {
             Word *fle = idat.IDict()->Address("runleave");     // set to address of word leave
             assert(fle != NULL);
             idat.BuildAddElement((long)ido);
             idat.BuildAddElement(fle);
          }
          else   // 'do' not found ??
          {
             idat.ShowError(Errors::NO_DO); 
          }
    }
    else   // not compiling
    {
      int doindex = (int ) idat.PopD();        // index of 'do' on stack 
      RSData ar = idat.GetRsv(0);              // get return stack entry (it called me)
      Word *calling = ar.Code();               // get the address of the word that called
              
      unsigned long loopind = 1001;
      calling->LiteralValue((doindex - 3), &loopind);  // get location in word of 'loop'
      unsigned long lim = 1001 ;
      calling->LiteralValue((doindex - 2), &lim); 
      calling->SetLiteralValue((doindex - 1), &lim);   // set loop index to limit

      if(calling->SameWord(loopind, "loop", idat))
      {
          ar.SetIndex((loopind  - 2));   // loop
      }
      else
      {
          ar.SetIndex((loopind  - 2));  // +loop
      }                     
      idat.SetRsv(ar, 0);        
    }
}

// Function name	: Primitives::L_unloop
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_rununloop(InterpreterData & idat)
{
     int doindex = (int ) idat.PopD();        // index of 'do' on stack 
      RSData ar = idat.GetRsv(0);              // get return stack entry (it called me)
      Word *calling = ar.Code();               // get the address of the word that called
              
      unsigned long key1 = 1234567;
      calling->SetLiteralValue((doindex - 2), &key1); 
      calling->SetLiteralValue((doindex - 1), &key1);   // set loop index to not in use    
}

// Function name	: Primitives::L_unloop
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_unloop(InterpreterData & idat)
{
    if(idat.Compiling())                       // compiling ?
    {   

          int iunloop = idat.ExtractNthLabeledAD("rununloop", 1);
          if(iunloop < 0)
          {
             iunloop = 1;
          }
          int ido = idat.FindNthLabeledAD("?rundo", "rundo", iunloop);

          if(ido >= 3)  // do uses 4 positions 
          {
             Word *funl = idat.IDict()->Address("rununloop");     // set to address of word unloop
             assert(funl != NULL);
             idat.BuildAddElement((long)ido);
             idat.BuildAddElement(funl);
             idat.PushLabeledAD("rununloop", (iunloop + 1));
          }
          else   // 'do' not found ??
          {
             idat.ShowError(Errors::NO_DO); 
          }
    }
    else   // not compiling
    {
      int doindex = (int ) idat.PopD();        // index of 'do' on stack 
      RSData ar = idat.GetRsv(0);              // get return stack entry (it called me)
      Word *calling = ar.Code();               // get the address of the word that called
              
      unsigned long key1 = 1234567;
      calling->SetLiteralValue((doindex - 2), &key1); 
      calling->SetLiteralValue((doindex - 1), &key1);   // set loop index to not in use    
    }
}

// Function name	: Primitives::L_tic
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_tic(InterpreterData & idat)
{
  string awrd;
  Parser * par = idat.IParser();
  char * wrd;
  Word * ww;

     if((wrd = par->NextWord()) != NULL)
     {
         awrd = wrd;
         if((ww = idat.IDict()->Address(awrd)) != NULL)  // word does exist
         {
              idat.PushD((unsigned long)ww); 
         }
         else
         {
              idat.ShowError(Errors::NO_SUCH_WORD);
         }
     }
     else
     {
         // buffer end reached
        idat.ShowError(Errors::BUFFER_END);
     }
}

// Function name	: Primitives::L_forget
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_forget(InterpreterData & idat)
{
  string awrd;
  Parser * par = idat.IParser();
  char * wrd;
  Word * ww;

     if((wrd = par->NextWord()) != NULL)
     {
         awrd = wrd;
         if(idat.IDict()->Forget(awrd) != -1)  // word does exist
         {
             ;
         }
         else
         {
              idat.ShowError(Errors::NO_SUCH_WORD);
         }
     }
     else
     {
         // buffer end reached
        idat.ShowError(Errors::BUFFER_END);
     }
}


// Function name	: Primitives::L_pound
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_pound(InterpreterData & idat)
{
   unsigned long base = *idat.Base();
   unsigned long uu = idat.PopD();
   unsigned long q = 0;
   unsigned long m;

   if(idat.NbufInUse()== true)
   {   
      q = uu / base;
      m = uu % base;
      char * buf = idat.Nbuffer();
      int bufpos = *idat.NbufferPos();

      if(m < 10l)
      {
         buf[bufpos] = (char)((unsigned long)'0' + m);
      }
      else
      {
         buf[bufpos] = (char)(((unsigned long)'A') + m - 10);
      }
      bufpos++;
     *(idat.NbufferPos()) = bufpos;
      idat.DebugTrace(buf);

      if(m != 0 || q != 0)
      {
        idat.PushD(q);
      }
   }
}


// Function name	: Primitives::L_pounds
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_pounds(InterpreterData & idat)
{
    unsigned long base = *idat.Base();
    unsigned long uu = uu = idat.PopD();
    unsigned long q = 0l;
    unsigned long m;
    
    if (uu == 0l)
    {
      uu = idat.PopD();
    }
    
    if(idat.NbufInUse() == true)
    {
        char * buf = idat.Nbuffer();
        int bufpos = *(idat.NbufferPos());    
        
        while(uu != 0 && bufpos < 118)
        {
            q = uu / base;
            m = uu % base;
            uu = q;
            if(m < 10l)
            {
                buf[bufpos] = (char)((unsigned long)'0' + m);
            }
            else
            {
                buf[bufpos] = (char)(((unsigned long)'A') + m - 10);
            }
            idat.DebugTrace(buf);
            bufpos++;
        }
       *(idat.NbufferPos()) = bufpos;
    }
    
    idat.PushD(q);
}


// Function name	: Primitives::L_lesspound
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_lesspound(InterpreterData & idat)
{
   if(idat.NbufInUse()== false)
   {
      idat.NbufferOn(); 
      memset(idat.Nbuffer(), 0, 120);
      *(idat.NbufferPos()) = 0;
   }
}


// Function name	: Primitives::L_hold
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_hold(InterpreterData & idat)
{
   if(idat.NbufInUse()== true)
   {   
      char cc = (char) idat.PopD();
      char * buf = idat.Nbuffer();
      int bufpos = *(idat.NbufferPos());
      buf[bufpos] = cc;
      bufpos++;
      *(idat.NbufferPos()) = bufpos;
   }
}


// Function name	: Primitives::L_sign
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_sign(InterpreterData & idat)
{
   if(idat.NbufInUse()== true)
   {   
      int nn = idat.PopD();
      if(nn < 0)
      {
         char * buf = idat.Nbuffer();
         int bufpos = *(idat.NbufferPos());
         buf[bufpos] = '-';
         bufpos++;
         *(idat.NbufferPos()) = bufpos;
      }
   }
}


// Function name	: Primitives::L_poundgreater
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_poundgreater(InterpreterData & idat)
{
   unsigned long uu = idat.PopD();
   if(idat.NbufInUse()== true)
   {
      idat.NbufferOff(); 
      char * nbuf = idat.Nbuffer();
      char * nobuf = idat.NObuffer();
      int bufpos = *(idat.NbufferPos());
      int kk = bufpos -1;

      for(int ii = kk;ii >= 0;ii--)
      {
        nobuf[kk - ii] = nbuf[ii];
      }
      nobuf[bufpos] = 0;
      idat.DebugTrace(nbuf);
      idat.DebugTrace(nobuf);
   }
   idat.PushD((long)idat.NObuffer());
   idat.PushD((long)strlen(idat.NObuffer()));
}

// Function name	: Primitives::L_bracketticbracket
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_bracketticbracket(InterpreterData & idat)
{
  string awrd;
  Parser * par = idat.IParser();
  char * wrd;
  Word * ww;

     if((wrd = par->NextWord()) != NULL)
     {
         awrd = wrd;
         if((ww = idat.IDict()->Address(awrd)) != NULL)  // word does exist
         {
              if(idat.Compiling())                          // compiling ?
              {  
                 idat.BuildAddElement((unsigned long)ww);
              }
              else
              {
                idat.ShowError(Errors::ONLY_COMPILED);
              }
         }
         else
         {
              idat.ShowError(Errors::NO_SUCH_WORD);
         }
     }
     else
     {
         // buffer end reached
        idat.ShowError(Errors::BUFFER_END);
     }
}


// Function name	: Primitives::L_execute
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_execute(InterpreterData & idat)
{
   Word * ww = ((Word *) idat.PopD());
   ww->Execute(0, idat);
}

void Primitives::L_decompile(InterpreterData & idat)
{
   string txt;
   txt.reserve(1000);
   Word * ww = ((Word *) idat.PopD());
   ww->Decompile(txt, idat);
   idat.Out() += txt;
   idat.WriteOut();
   idat.LineOut();
}


// Function name	: Primitives::L_dot_s
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_dot_s(InterpreterData & idat)
{
   idat.ShowDatv();
}

// Function name	: Primitives::L_case
// Description	    : ( val -- )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_runcase(InterpreterData & idat)
{
   idat.PopD();
}

// Function name	: Primitives::L_case
// Description	    : ( val -- ) 
// internal-runtime           : ( val - val )
// internal compile-time      : AD( -- runcase-index[runcase]
//                       prepares for the index of endcase so that endof will have a known 
//                       location to find it at run time only drops the endcase index
//                       puts the index value of case on the aux data stack
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_case(InterpreterData & idat)
{
    if(idat.Compiling())                   // compiling ??
    {   
          Word *fcase = idat.IDict()->Address("runcase");  // address of word 'case'
          
          idat.BuildAddElement((long)0);    // for endcase
          idat.BuildAddElement(fcase);
          long ee = idat.BuildLastUsedElement();           
          idat.PushLabeledAD((unsigned long) fcase, ee);
    }
    else  // not compiling
    {
       idat.PopD();
    }
}

// Function name	: Primitives::L_runof
// Description	    : ( val -- )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_runof(InterpreterData & idat)
{
          long ind = idat.PopD();
          long val = idat.PopD();
          long val2 = idat.PopD();
          if(val != val2) // jump to endof with valin on stack
          {
             idat.PushD(val2);
             RSData ar = idat.GetRsv(0);
             ar.SetIndex(ind); 
             idat.SetRsv(ar, 0); // will be invremented by execute apon return
          }

}

// Function name	: Primitives::L_of
// Description	    : ( val -- )
// internal-runtime           : ( valin valtst index[endof] -- valin | <empty) )
// internal compile-time      : AD( ---  runcase-index[runcase] runof--index[runof]
//                          prepares for the index of endof puts the of index value on the aux stask
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_of(InterpreterData & idat)
{
    if(idat.Compiling())                   // compiling ??
    {   
          Word *fof = idat.IDict()->Address("runof");  // address of word 'of'
          
          idat.BuildAddElement((long)0);   // for endof
          idat.BuildAddElement(fof);
          long ee = idat.BuildLastUsedElement();           
          idat.PushLabeledAD((unsigned long) fof, ee);
    }
    else  // not compiling
    {
          long ind = idat.PopD();
          long val = idat.PopD();
          long val2 = idat.PopD();
          if(val != val2)
          {
             idat.PushD(val2);
             RSData ar = idat.GetRsv(0);
             ar.SetIndex(ind); 
             idat.SetRsv(ar, 0);
          }
    }
}

// Function name	: Primitives::L_endof
// Description	    : ( val -- )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_runendof(InterpreterData & idat)
{
         unsigned long ind = idat.PopD();             // index of case - 1

         RSData ar = idat.GetRsv(0);
         Word *calling = ar.Code();                   // get the address of the word that called              
         unsigned long endcaseind = 1001;
         calling->LiteralValue(ind, &endcaseind); 
         ar.SetIndex(endcaseind); 
         idat.SetRsv(ar, 0);
}

// Function name	: Primitives::L_endof
// Description	    : ( val -- )
// internal-runtime1       : ( empty case-1=index[endcase] -- )
//                           at runtime the only endof should only be reached if the of was 
//                           passed and we jump to endcase
// internal compile-time   : AD( runof--index[runof] runcase-index[runcase] --- runcase-index[runcase]
//                           gets the index locations of of and case from the aux data stack
//                           and adds the index (case - 1 = endcase index ! and sets the location
//                           of - 1 to endof
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_endof(InterpreterData & idat)
{
    if(idat.Compiling())                   // compiling ??
    {   
          Word *fendof = idat.IDict()->Address("runendof");  // address of word 'endof'
          
          unsigned long ofindex = idat.PopLabeledAD();             // of index
          unsigned long caseindex = idat.PeekLabeledAD();          // case index
              
          idat.BuildAddElement((long)caseindex - 1);               // for endcase
          idat.BuildAddElement(fendof);                            
          unsigned long ee = idat.BuildLastUsedElement();          
          idat.Building()->SetLiteralValue(ofindex-1, &ee);     
    }
    else  // not compiling
    {
         unsigned long ind = idat.PopD();             // index of case - 1

         RSData ar = idat.GetRsv(0);
         Word *calling = ar.Code();               // get the address of the word that called              
         unsigned long endcaseind = 1001;
         calling->LiteralValue(ind, &endcaseind); 
         ar.SetIndex(endcaseind); 
         idat.SetRsv(ar, 0);
    }
}

// Function name	: Primitives::L_runendcase
// Description	    : ( val -- )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_runendcase(InterpreterData & idat)
{
  ;
}

// Function name	: Primitives::L_endcase
// Description	    : ( -- )
// internal compile-time   : AD( runcase-index[runcase] --          
//                    gets the index of case from the auxilary data stack and the endcase index into
//                    that location so that endof can jump to if its executed at runtime       
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_endcase(InterpreterData & idat)
{
    if(idat.Compiling())                   // compiling ??
    {   
          Word *fendcase = idat.IDict()->Address("runendcase");  // address of word 'endcase'
          
          unsigned long caseindex = idat.PopLabeledAD();               // case index
           
          idat.BuildAddElement(fendcase);
          unsigned long ee = idat.BuildLastUsedElement();          
          idat.Building()->SetLiteralValue(caseindex - 1, &ee);     
    }
}

// Function name	: Primitives::L_immediate
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_immediate(InterpreterData & idat)
{
  ((idat.IDict())->MostRecent())->SetFlags(idat.ExecuteCompile);
}


// Function name	: Primitives::L_tocontext
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_tocontext(InterpreterData & idat)
{
  Word * ww = idat.ExvWord();
  (idat.IDict())->MakeContext(ww->Name());
}


// Function name	: Primitives::L_forth
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_forth(InterpreterData & idat)
{
  string sf = "forth";
  (idat.IDict())->MakeContext(sf); 
}


// Function name	: Primitives::L_vocabulary
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_vocabulary(InterpreterData & idat)
{
    string awrd;
    Parser * par = idat.IParser();
    char * wrd;
    
    if(idat.Compiling())
    {
        // the word vocabulary is only interpreted "to create a vocabulary'
        idat.ShowError(Errors::ILLEGALDEFINING);
        return;
    }
    
    if((wrd = par->NextWord()) != NULL)
    {
        awrd = wrd;
        if(idat.IDict()->Exists(awrd) == -1)  // word does not exist
        {
            if(!par->AllDigits(wrd))         // word is not a number
            {
                if((idat.IDict())->AddVoc(awrd))
                {
                    idat.BuildWithName(awrd); 
                    Element *pel = new Element(&Primitives::L_tocontext);
                    idat.BuildAddElement((*pel));  
                    delete pel;
                    idat.BuildFinishWord();
                }
                else
                {
                    idat.ShowError(Errors::WORD_EXISTS, awrd);
                }
            }
            else
            {
                // trying to name a word with a number error
                idat.ShowError(Errors::IS_NUMBER);
            }
        }
        else
        {
            // word already exists error
            idat.ShowError(Errors::WORD_EXISTS, awrd);
        }
    } 
    else
    {
        // buffer end reached
        idat.ShowError(Errors::BUFFER_END);
    }
}


// Function name	: Primitives::L_definitions
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_definitions(InterpreterData & idat)
{
  (idat.IDict())->ContextToCurrent();
}


// Function name	: Primitives::L_literal
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_literal(InterpreterData & idat)
{
    if(idat.Compiling())
    {
       unsigned long gg = idat.PopD();
       idat.BuildAddElement(gg);
    }
    else
    {
       idat.ShowError(Errors::ONLY_COMPILED);
    }
}


// Function name	: Primitives::L_postpone
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_postpone(InterpreterData & idat)
{
    string awrd;
    Parser * par = idat.IParser();
    char * wrd;
    
    if(idat.Compiling())
    {
        if((wrd = par->NextWord()) != NULL)
        {
            awrd = wrd;
            Word *postpned = idat.IDict()->Address(awrd);
            if(postpned != NULL)
            {
                idat.BuildAddElement(postpned);
            }
            else
            {
                idat.ShowError(Errors::NO_SUCH_WORD, awrd);
            }
        }
        else
        {
            // buffer end reached
            idat.ShowError(Errors::BUFFER_END);
        }
    }
    else
    {
        idat.ShowError(Errors::ONLY_COMPILED);
    }  
}


// Function name	: Primitives::L_vocquery
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_vocquery(InterpreterData & idat)
{
  Word * ww = (Word *) idat.PopD();
  string vf;
  vf.reserve(60);

  bool ar = (idat.IDict())->VocNameForWord(ww , vf);
  if(ar == true)
  {
    idat.Out() += vf.c_str();
    idat.WriteOut(); 
  }
  else
  {
    idat.Out() += "Word not found";
    idat.WriteOut(); 
  }
}


// Function name	: Primitives::L_bl
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_bl(InterpreterData & idat)
{
  idat.PushD((long)' ');
}

// Function name	: Primitives::L_word
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_word(InterpreterData & idat)
{
  char delim = idat.PopD();
  Parser * ppar = idat.IParser();
  char nch = 0;

  while( ((nch = ppar->GetChar()) == delim)  || isspace(nch)) 
  {
    ppar->Advance();
  }

  char *cs = idat.WordBuf();
  char *cc = cs;
  cc += 4;
  *((long *)cs) = 0;

  for(long ii = 0;ii < 300; ii++)
  {
    nch = ppar->GetChar(); 
    if(nch != delim)
    {
       cc[ii] = nch;
       cc[ii + 1] = 32;
       cc[ii + 2] = 0;
       *((long *)cs) = ii + 1;
       ppar->Advance();
       if(nch == 0)
       {
          break;
       }
    }
    else
    {
       ppar->Advance();
       break;
    }
  }
  ppar->Advance();
  idat.PushD((unsigned long)cs);
}

// Function name	: Primitives::L_create
// Description	    : create <word> ... ;create | does> ... ;
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_create(InterpreterData & idat)
{
  string awrd;
  Parser * par = idat.IParser();
  char * wrd;

 if((wrd = par->NextWord()) != NULL)
 {
    awrd = wrd;
    long lval = 0l;
    if(idat.IDict()->Exists(awrd) == -1)  // word does not exist
    {
         if(!par->AllDigits(wrd))         // word is not a number
         { 
           idat.BuildWithName(awrd); 
           idat.BuildAddElement(lval);  
         }
         else
         {
            // trying to name a word with a number error
            idat.ShowError(Errors::IS_NUMBER);
         }
    }
    else
     {
        // word already exists error
        idat.ShowError(Errors::WORD_EXISTS, awrd);
     }
 } 
 else
 {
      // buffer end reached
      idat.ShowError(Errors::BUFFER_END);
 }
}


// Function name	: Primitives::L_endcreate
// Description	    : create <word> ... ;create | does> ... ;
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_endcreate(InterpreterData & idat)
{
  Word * ww = idat.Building();
  if(ww != NULL)
  {
    idat.BuildFinishWord();
  }
  else
  {
    idat.ShowError(Errors::NO_CREATE);
  }
}

// Function name	: Primitives::L_allot
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_allot(InterpreterData & idat)
{
  long nn = idat.PopD();
  unsigned long uu = (unsigned long) idat.MManager().AllocateType(MemInstDat::m_CharArray, nn+1);
  Word * ww = idat.Building();
  if(ww != NULL)
  {
     unsigned long ee = idat.BuildLastUsedElement();
     idat.Building()->SetLiteralValue(ee, &uu);
  }
  else
  {
     idat.MManager().DeleteMem((void *) uu, MemInstDat::m_CharArray);
     idat.ShowError(Errors::NO_CREATE);
  }
}


// Function name	: Primitives::L_execute_at
// Description	    : ( index word -- )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_execute_at(InterpreterData & idat)
{   
   Word *ww = (Word *) idat.PopD();
   int ind = idat.PopD();

 //  RSData rr(ww);
 //  rr.SetIndex(ind);
 //  idat.PushR(rr);
   ww->Execute(ind, idat);
}

// Function name	: Primitives::L_does
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_rundoes(InterpreterData & idat)
{
  Word * ww;
  unsigned long ee;

    ww = idat.Building();
    if(ww != NULL)
    {
        RSData ar = idat.GetRsv(0);
        Word *calling = ar.Code();    
        ee = idat.PopD();

       if(calling != NULL)
       {
          idat.BuildAddElement(ee + 3);
          idat.BuildAddElement((unsigned long)calling);
          Element *pel = new Element(&Primitives::L_execute_at);
          idat.BuildAddElement((*pel));
          idat.BuildFinishWord();
          delete pel;
          int ind = calling->NextIndex();
          ar.SetIndex(ind - 1);
          idat.SetRsv(ar, 0);
       }
       else
       {
          idat.ShowError(Errors::SYNTAX_ERROR);
       }
    }
    else
    {
       idat.ShowError(Errors::NO_CREATE);
    }
}

// Function name	: Primitives::L_does
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_does(InterpreterData & idat)
{
  Word * ww;
  unsigned long ee;

  if(idat.Compiling())
  {
     ww = idat.Building();
     ee = idat.BuildLastUsedElement();
     idat.BuildAddElement(ee);
     Word *fdoes = idat.IDict()->Address("rundoes>");
     idat.BuildAddElement(fdoes);
  }
  else
  {
    ww = idat.Building();
    if(ww != NULL)
    {
        RSData ar = idat.GetRsv(0);
        Word *calling = ar.Code();    
        ee = idat.PopD();

       if(calling != NULL)
       {
          idat.BuildAddElement(ee + 3);
          idat.BuildAddElement((unsigned long)calling);
          Element *pel = new Element(&Primitives::L_execute_at);
          idat.BuildAddElement((*pel));
          idat.BuildFinishWord();
          delete pel;
          int ind = calling->NextIndex();
          ar.SetIndex(ind - 1);
          idat.SetRsv(ar, 0);
       }
       else
       {
          idat.ShowError(Errors::SYNTAX_ERROR);
       }
    }
    else
    {
       idat.ShowError(Errors::NO_CREATE);
    }
  }
}

// Function name	: Primitives::L_exit
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_runexit(InterpreterData & idat)
{
       RSData ar = idat.GetRsv(0);
       Word *calling = ar.Code();   
       int ind = calling->NextIndex();
       ar.SetIndex(ind - 1);
       idat.SetRsv(ar, 0);
}


// Function name	: Primitives::L_exit
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_exit(InterpreterData & idat)
{
    if(idat.Compiling())
    {
       idat.ExtractNthLabeledAD("rununloop", 1);       
       Word *fexit = idat.IDict()->Address("runexit");
       idat.BuildAddElement(fexit);
    }
    else
    {
       RSData ar = idat.GetRsv(0);
       Word *calling = ar.Code();   
       int ind = calling->NextIndex();
       ar.SetIndex(ind - 1);
       idat.SetRsv(ar, 0);
    }
}


// Function name	: Primitives::L_recurse
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_recurse(InterpreterData & idat)
{
    RSData ar = idat.GetRsv(0);
    Word *calling = ar.Code();   
    calling->Execute(0, idat);
}


// Function name	: Primitives::L_leftbracket
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_leftbracket(InterpreterData & idat)
{
   idat.EndCompile();
}


// Function name	: Primitives::L_rightbracket
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_rightbracket(InterpreterData & idat)
{
   idat.Compile();
}


// Function name	: Primitives::L_quit
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_quit(InterpreterData & idat)
{
   Word * fnop = idat.IDict()->Address("nop");
   Word * ww = NULL;
   RSData ar;

   while(fnop != ww)
   {
     ar = idat.PopR(); 
     ww = ar.Code();
   }
   idat.PushR(ar);
}


// Function name	: Primitives::L_release
// Description	    : Remove a vocabulary from the search list
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_release(InterpreterData & idat)
{
  string awrd;
  Parser * par = idat.IParser();
  char * wrd;
  long vv = 0L;

 if((wrd = par->NextWord()) != NULL)
 {
    awrd = wrd;
    Word *fv = idat.IDict()->Address(awrd);
    if(fv != NULL)
    {
       string sv = fv->Name();
       vv = idat.IDict()->RemoveVocSearch(sv);
    }
 }
 idat.PushD((long)vv);
}


// Function name	: Primitives::L_rpush
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_rpush(InterpreterData & idat)
{
  RSData ar, mr;
   mr = idat.PopR();

  void * vv = (void *) idat.PopD();
  if(idat.MManager().IsMem(vv, MemInstDat::m_RSData))
  {
    RSData * qq = (RSData *) vv;
    idat.PushR(*qq);
    idat.MManager().DeleteMem(vv, MemInstDat::m_RSData);
  }
  else
  {
    Word *fn = idat.IDict()->Address("nop");
    ar.SetCode(fn);
    ar.SetIndex((unsigned long) vv);
    idat.PushR(ar);
  }
  idat.PushR(mr);
}


// Function name	: Primitives::L_rpop
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_rpop(InterpreterData & idat)
{
  RSData mr, mw;
  mr = idat.PopR();

  long rr;

  RSData *par = (RSData *) idat.MManager().AllocateType(MemInstDat::m_RSData, 0);
  *par = idat.PopR();
  Word *fn = idat.IDict()->Address("nop");
  Word *fr = par->Code();

  if(fr == fn)
  {
    rr = par->Index();
    idat.MManager().DeleteMem((void *)par, MemInstDat::m_RSData);
  }
  else
  {
    rr = (unsigned long) par;
  }
  idat.PushD(rr);
  idat.PushR(mr);
}


// Function name	: Primitives::L_rfetch
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_rfetch(InterpreterData & idat)
{
  long rr;
  RSData *par = (RSData *) idat.MManager().AllocateType(MemInstDat::m_RSData, 0);
  *par = idat.GetRsv(1);
  Word *fn = idat.IDict()->Address("nop");
  Word * fr = par->Code();
  if(fr == fn)
  {
    rr = par->Index();
    idat.MManager().DeleteMem((void *)par, MemInstDat::m_RSData);
  }
  else
  {
    rr = (unsigned long) par;
  }
  idat.PushD(rr);
}

// Function name	: Primitives::L_nip
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_nip(InterpreterData & idat)
{
  long qq = idat.PopD();
  idat.PopD();
  idat.PushD(qq);
}


// Function name	: Primitives::L_roll
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_roll(InterpreterData & idat)
{
  long qq = idat.PopD();
  idat.RollDatv(qq);
}


// Function name	: Primitives::L_pick
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_pick(InterpreterData & idat)
{
  long qq = idat.PopD();
  long gg = idat.GetDatv(qq);
  idat.PushD(gg);
}

// Function name	: Primitives::L_twodup
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_twodup(InterpreterData & idat)
{
   long qq = idat.PopD();
  long rr = idat.PopD();
  idat.PushD(rr);
  idat.PushD(qq);
  idat.PushD(rr);
  idat.PushD(qq);  
}

// Function name	: Primitives::L_twoswap
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_twoswap(InterpreterData & idat)
{
  long qq = idat.PopD();
  long rr = idat.PopD();
  long ss = idat.PopD();
  long tt = idat.PopD();

  idat.PushD(rr);
  idat.PushD(qq);
  idat.PushD(tt);
  idat.PushD(ss);  
}

// Function name	: Primitives::L_twoswap
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_twoover(InterpreterData & idat)
{
  long qq = idat.PopD();  // 4
  long rr = idat.PopD();  // 3
  long ss = idat.PopD();  // 2 
  long tt = idat.PopD();  // 1

  idat.PushD(tt);
  idat.PushD(ss);
  idat.PushD(rr);
  idat.PushD(qq);  
  idat.PushD(tt);
  idat.PushD(ss);
}

// Function name	: Primitives::L_twodrop
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_twodrop(InterpreterData & idat)
{
  long qq = idat.PopD();
  long rr = idat.PopD();
}

// Function name	: Primitives::L_cell
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_cell(InterpreterData & idat)
{
  idat.PushD(sizeof(long));  
}

// Function name	: Primitives::L_cellplus
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_cellplus(InterpreterData & idat)
{
  long qq = idat.PopD();
  idat.PushD((qq + sizeof(long))); 
}

// Function name	: Primitives::L_cellplus
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_charplus(InterpreterData & idat)
{
  long qq = idat.PopD();
  idat.PushD((qq + sizeof(char))); 
}

// Function name	: Primitives::L_cells
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_cells(InterpreterData & idat)
{
  long qq = idat.PopD();
  idat.PushD((qq * sizeof(long)));  
}

// Function name	: Primitives::L_chars
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_chars(InterpreterData & idat)
{
  long qq = idat.PopD();
  idat.PushD((qq * sizeof(char)));  
}

// Function name	: Primitives::L_fill
// Description	    : ( addr u char -- )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_fill(InterpreterData & idat)
{
  int cc = (int) idat.PopD();
  long uu = idat.PopD();
  char * adr = (char *) idat.PopD();

  memset(adr, cc, uu);
}

// Function name	: Primitives::L_move
// Description	    : ( addr u char -- )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_move(InterpreterData & idat)
{
  long cc = idat.PopD();
  char* adr1 = (char *) idat.PopD();
  char* adr2 = (char *) idat.PopD();

  memmove(adr1, adr2, cc);
}

// Function name	: Primitives::L_true
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_true(InterpreterData & idat)
{
  idat.PushD((long)true);  
}


// Function name	: Primitives::L_false
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_false(InterpreterData & idat)
{
  idat.PushD((long)false);  
}

// Function name	: Primitives::L_memsize
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_memsize(InterpreterData & idat)
{
  void *vv = (void *) idat.PopD();
  long qq = idat.MManager().MemSize(vv);
  idat.PushD(qq);
}


// Function name	: Primitives::L_auxpush
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_auxpush(InterpreterData & idat)
{
  long qq = idat.PopD();
  idat.PushAD((long)qq);
}


// Function name	: Primitives::L_auxpop
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_auxpop(InterpreterData & idat)
{
  long qq = idat.PopAD();
  idat.PushD(qq);
}


// Function name	: Primitives::L_auxswap
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_auxswap(InterpreterData & idat)
{
  long qq = idat.PopAD();
  long mm = idat.PopAD();
  idat.PushAD((long)qq);
  idat.PushAD((long)mm);
}


// Function name	: Primitives::L_auxdrop
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_auxdrop(InterpreterData & idat)
{
   long aa = idat.PopAD();
}

// Function name	: Primitives::L_auxover
// Description	    : ( n1 n2 --- n1 n2 n1 )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_auxover(InterpreterData & idat)
{
   long aa = idat.PopAD();  // n2
   long bb = idat.PopAD();  // n1
   idat.PushAD(bb);         // n1
   idat.PushAD(aa);         // n2
   idat.PushAD(bb);         // n1
}

// Function name	: Primitives::L_auxrot
// Description	    : ( n1 n2 n3 --- n2 n3 n1 )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_auxrot(InterpreterData & idat)
{
   long aa = idat.PopAD();  // a
   long bb = idat.PopAD();  // b
   long cc = idat.PopAD();  // c
   idat.PushAD((long)bb);
   idat.PushAD((long)aa);
   idat.PushAD((long)cc);
}

// Function name	: Primitives::L_auxreverserot
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_auxreverserot(InterpreterData & idat)
{
   long aa = idat.PopAD();  // n3
   long bb = idat.PopAD();  // n2
   long cc = idat.PopAD();  // n1
   idat.PushAD((long)aa);
   idat.PushAD((long)cc);
   idat.PushAD((long)bb);
}

void Primitives::L_auxtuck(InterpreterData & idat)
{
   long aa = idat.PopAD();
   long bb = idat.PopAD();

   idat.PushAD((long)(aa));
   idat.PushAD((long)(bb));
   idat.PushAD((long)(aa));
}


// Function name	: Primitives::L_auxfetch
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_auxfetch(InterpreterData & idat)
{
  long qq = idat.PopAD();
  idat.PushAD(qq);
  idat.PushD(qq);
}

// Function name	: Primitives::L_nip
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_auxnip(InterpreterData & idat)
{
  long qq = idat.PopAD();
  idat.PopAD();
  idat.PushAD(qq);
}

// Function name	: Primitives::L_auxroll
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_auxroll(InterpreterData & idat)
{
  long qq = idat.PopD();
  idat.RollADatv(qq);
}

// Function name	: Primitives::L_auxpick
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_auxpick(InterpreterData & idat)
{
  long qq = idat.PopD();
  long gg = idat.GetADatv(qq);
  idat.PushAD(gg);
}

// Function name	: Primitives::L_auxtwodup
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_auxtwodup(InterpreterData & idat)
{
  long qq = idat.PopAD();
  long rr = idat.PopAD();
  idat.PushAD(rr);
  idat.PushAD(qq);
  idat.PushAD(rr);
  idat.PushAD(qq);  
}


// Function name	: Primitives::L_auxtwodrop
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_auxtwodrop(InterpreterData & idat)
{
  long qq = idat.PopAD();
  long rr = idat.PopAD();
}


// Function name	: Primitives::L_timeanddate
// Description	    : ( -- +n1 +n2 +n3 +n4 +n5 +n6 )
// The current time and date. +n1 is the second {0...59}, 
// +n2 is the minute {0...59}, +n3 is the hour {0...23}, 
// +n4 is the day {1...31} +n5 is the month {1...12}, 
// and +n6 is the year (e.g., 1991). 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_timeanddate(InterpreterData & idat)
{
   time_t ltime;
   struct tm *today;
   time(&ltime);
   today = localtime(&ltime);
   idat.PushD((long)today->tm_sec);
   idat.PushD((long)today->tm_min);
   idat.PushD((long)today->tm_hour);
   idat.PushD((long)today->tm_mday);
   idat.PushD((long)(today->tm_mon + 1));
   idat.PushD((long)(today->tm_year + 1900));
}

// Function name	: Primitives::L_tuck
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_tuck(InterpreterData & idat)
{
   long aa = idat.PopD();
   long bb = idat.PopD();

   idat.PushD((long)(aa));
   idat.PushD((long)(bb));
   idat.PushD((long)(aa));
}


// Function name	: Primitives::L_within
// Description	    : ( n1|u1 n2|u2 n3|u3 -- flag )
// (n2|u2 < n3|u3 and (n2|u2 <= n1|u1 and n1|u1 < n3|u3)) 
// or (n2|u2 > n3|u3 and (n2|u2 <= n1|u1 or n1|u1 < n3|u3)) is true
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_within(InterpreterData & idat)
{
   long n3 = idat.PopD();
   long n2 = idat.PopD();
   long n1 = idat.PopD();

   if(n2 < n3)
   {
     if(n2 <= n1 && n1 < n3)
     {
       idat.PushD((unsigned long)(true));
       return;
     }
   }
  if(n2 > n3)
   {
     if(n2 <= n1 || n1 < n3)
     {
       idat.PushD((long)(true));
       return;
     }
   }
  idat.PushD((long)(false));
}

// floating point words


// Function name	: Primitives::L_ftimes
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_ftimes(InterpreterData & idat)
{
   double n3 = idat.PopFD();
   double n2 = idat.PopFD();
   idat.PushFD((n3 * n2));
}


// Function name	: Primitives::L_fplus
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_fplus(InterpreterData & idat)
{
   double n3 = idat.PopFD();
   double n2 = idat.PopFD();
   idat.PushFD((n3 + n2));
}


// Function name	: Primitives::L_fminus
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_fminus(InterpreterData & idat)
{
   double n3 = idat.PopFD();
   double n2 = idat.PopFD();
   idat.PushFD((n2 - n3));
}


// Function name	: Primitives::L_fdivide
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_fdivide(InterpreterData & idat)
{
   double n3 = idat.PopFD();
   double n2 = idat.PopFD();
   if (n3 == 0.0)
   {
      idat.ShowError(Errors::DIVIDEBYZERO);
   }
   else
   {
     idat.PushFD((n2 / n3));
   }
}


// Function name	: Primitives::L_dtof
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_dtof(InterpreterData & idat)
{
   long n3 = idat.PopD();
   idat.PushFD(((double)n3));
}


// Function name	: Primitives::L_ftod
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_ftod(InterpreterData & idat)
{
   double aa = idat.PopFD();
   idat.PushD(((long)aa));
}


// Function name	: Primitives::L_fzeroless
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_fzeroless(InterpreterData & idat)
{
   double n3 = idat.PopFD();
   if(n3 < 0.0)
   {
     idat.PushD(true);
   }
   else  
   {
     idat.PushD((long) false);
   }
}


// Function name	: Primitives::L_fzeroequal
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_fzeroequal(InterpreterData & idat)
{
   double n3 = idat.PopFD();
   if(n3 == 0.0)
   {
     idat.PushD(true);
   }
   else  
   {
     idat.PushD((long) false);
   }
}


// Function name	: Primitives::L_fless
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_fless(InterpreterData & idat)
{
   double aa = idat.PopFD();
   double bb = idat.PopFD();

   if(bb < aa)
   {
     idat.PushD(true);
   }
   else  
   {
     idat.PushD((long) false);
   }
}


// Function name	: Primitives::L_flessequal
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_flessequal(InterpreterData & idat)
{
   double aa = idat.PopFD();
   double bb = idat.PopFD();

   if(bb <= aa)
   {
     idat.PushD(true);
   }
   else  
   {
     idat.PushD((long) false);
   }
}


// Function name	: Primitives::L_fgreater
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_fgreater(InterpreterData & idat)
{
   double aa = idat.PopFD();
   double bb = idat.PopFD();

   if(bb > aa)
   {
     idat.PushD(true);
   }
   else  
   {
     idat.PushD((long) false);
   }
}


// Function name	: Primitives::L_fgreaterequal
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_fgreaterequal(InterpreterData & idat)
{
   double aa = idat.PopFD();
   double bb = idat.PopFD();

   if(bb >= aa)
   {
     idat.PushD(true);
   }
   else  
   {
     idat.PushD((long) false);
   }
}


// Function name	: Primitives::L_fdrop
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_fdrop(InterpreterData & idat)
{
   idat.PopFD();
}


// Function name	: Primitives::L_fdup
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_fdup(InterpreterData & idat)
{
   double aa = idat.PopFD();
   idat.PushFD(aa);
   idat.PushFD(aa);
}


// Function name	: Primitives::L_fnip
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_fnip(InterpreterData & idat)
{
  double qq = idat.PopFD();
  idat.PopFD();
  idat.PushFD(qq);
}


// Function name	: Primitives::L_froll
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_froll(InterpreterData & idat)
{
  long qq = idat.PopD();
  idat.RollFDatv(qq);
}


// Function name	: Primitives::L_fpick
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_fpick(InterpreterData & idat)
{
  long qq = idat.PopD();
  long gg = idat.GetFDatv(qq);
  idat.PushFD(gg);
}

void Primitives::L_fover(InterpreterData & idat)
{
   double aa = idat.PopFD();  // n2
   double bb = idat.PopFD();  // n1
   idat.PushAD(bb);         // n1
   idat.PushAD(aa);         // n2
   idat.PushAD(bb);         // n1
}

// Function name	: Primitives::L_frot
// Description	    : ( f1 f2 f3 --- f2 f3 f1 )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_frot(InterpreterData & idat)
{
   double aa = idat.PopFD();  // a
   double bb = idat.PopFD();  // b
   double cc = idat.PopFD();  // c
   idat.PushFD(bb);
   idat.PushFD(aa);
   idat.PushFD(cc);
}

// Function name	: Primitives::L_freverserot
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_freverserot(InterpreterData & idat)
{
   double aa = idat.PopFD();  // a
   double bb = idat.PopFD();  // b
   double cc = idat.PopFD();  // c
   idat.PushFD(aa);
   idat.PushFD(cc);
   idat.PushFD(bb);
}


// Function name	: Primitives::L_ftuck
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_ftuck(InterpreterData & idat)
{
   double aa = idat.PopFD();  // a
   double bb = idat.PopFD();  // b

   idat.PushFD(aa);
   idat.PushFD(bb);
   idat.PushFD(aa);
}


// Function name	: Primitives::L_fpower
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_fpower(InterpreterData & idat)
{
   double n3 = idat.PopFD();
   double n2 = idat.PopFD();
   idat.PushFD(pow( n2, n3));
}


// Function name	: Primitives::L_fabs
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_fabs(InterpreterData & idat)
{
   double aa = idat.PopFD();
   idat.PushFD(fabs( aa));
}


// Function name	: Primitives::L_facos
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_facos(InterpreterData & idat)
{
   double aa = idat.PopFD();
   idat.PushFD(acos( aa));
}


// Function name	: Primitives::L_fcos
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_fcos(InterpreterData & idat)
{
   double aa = idat.PopFD();
   idat.PushFD(cos( aa));
}


// Function name	: Primitives::L_fcosh
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_fcosh(InterpreterData & idat)
{
   double aa = idat.PopFD();
   idat.PushFD(cosh( aa));
}

//void Primitives::L_facosh(InterpreterData & idat)
//{
//   double aa = idat.PopFD();
//   idat.PushFD(acosh( aa));
//}

void Primitives::L_fasin(InterpreterData & idat)
{
   double aa = idat.PopFD();
   idat.PushFD(asin( aa));
}


// Function name	: Primitives::L_fsin
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_fsin(InterpreterData & idat)
{
   double aa = idat.PopFD();
   idat.PushFD(sin( aa));
}


// Function name	: Primitives::L_fsincos
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_fsincos(InterpreterData & idat)
{
   double aa = idat.PopFD();
   idat.PushFD(cos( aa));
   idat.PushFD(sin( aa));
}


// Function name	: Primitives::L_fsinh
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_fsinh(InterpreterData & idat)
{
   double aa = idat.PopFD();
   idat.PushFD(sinh( aa));
}

//void Primitives::L_fasinh(InterpreterData & idat)
//{
//   double aa = idat.PopFD();
//   idat.PushFD(asinh( aa));
//}


// Function name	: Primitives::L_fatan
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_fatan(InterpreterData & idat)
{
   double aa = idat.PopFD();
   idat.PushFD(atan( aa));
}


// Function name	: Primitives::L_ftan
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_ftan(InterpreterData & idat)
{
   double aa = idat.PopFD();
   idat.PushFD(tan( aa));
}


// Function name	: Primitives::L_ftanh
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_ftanh(InterpreterData & idat)
{
   double aa = idat.PopFD();
   idat.PushFD(tanh( aa));
}


// Function name	: Primitives::L_fatan2
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_fatan2(InterpreterData & idat)
{
   double xx = idat.PopFD();
   double yy = idat.PopFD();

   idat.PushFD(atan2( yy, xx));
}


// Function name	: Primitives::L_fexp
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_fexp(InterpreterData & idat)
{
   double aa = idat.PopFD();
   idat.PushFD(exp( aa));
}


// Function name	: Primitives::L_fln
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_fln(InterpreterData & idat)
{
   double aa = idat.PopFD();
   idat.PushFD(log( aa));
}


// Function name	: Primitives::L_flog
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_flog(InterpreterData & idat)
{
   double aa = idat.PopFD();
   idat.PushFD(log10( aa));
}


// Function name	: Primitives::L_sqrt
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_sqrt(InterpreterData & idat)
{
   double aa = idat.PopFD();
   idat.PushFD(sqrt( aa));
}


// Function name	: Primitives::L_fdot
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_fdot(InterpreterData & idat)
{
   double aa = idat.PopFD();
   char ss[35];
   sprintf(ss," %f ",aa);
   idat.Out() += ss;
   idat.WriteOut();
}


// Function name	: Primitives::L_fmin
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_fmin(InterpreterData & idat)
{
   double xx = idat.PopFD();
   double yy = idat.PopFD();

   idat.PushFD(__min( yy, xx));
}


// Function name	: Primitives::L_fmax
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_fmax(InterpreterData & idat)
{
   double xx = idat.PopFD();
   double yy = idat.PopFD();

   idat.PushFD(__max( yy, xx));
}


// Function name	: Primitives::L_fnegate
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_fnegate(InterpreterData & idat)
{
   double xx = idat.PopFD();
   idat.PushFD(-xx);
}

// void Primitives::L_ftofloat(InterpreterData & idat)
//{
//   long xx = idat.PopD();  // 
//  
//   idat.PushFD(-xx);
//}


// end floating point


// Function name	: Primitives::L_ReadEntireFile
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_ReadEntireFile(InterpreterData & idat)
{
  string * st = ((string *) idat.PopD());
  int fh;
  char *buf;

  if((fh = _open(st->c_str(), _O_RDONLY )) >= 0)
  {
    long ll = filelength(fh);
    buf = (char *) idat.MManager().AllocateType(MemInstDat::m_CharArray, (ll+1));
    read(fh, buf, ll);
    close(fh);
  }
  idat.PushD((long)buf);
}

void Primitives::L_CreateFile(InterpreterData & idat)
{
    long fam = idat.PopD();
    long len = idat.PopD();
    char * fn = (char*) idat.PopD();
    int fh;

    if((fh = _open(fn, _O_RDWR | _O_CREAT, _S_IREAD | _S_IWRITE )) != (-1))
    {
       idat.PushD(fh);
       idat.PushD(0L);
    }
    idat.PushD(fh);
    idat.PushD(errno);
}

void Primitives::L_ReadOnly(InterpreterData & idat)
{
   idat.PushD((long)_O_RDONLY);
}

void Primitives::L_ReadWrite(InterpreterData & idat)
{
   idat.PushD(_O_RDWR);
}

void Primitives::L_WriteOnly(InterpreterData & idat)
{
   idat.PushD(_O_WRONLY);
}

void Primitives::L_OpenFile(InterpreterData & idat)
{
    long fam = idat.PopD();
    long len = idat.PopD();
    char * fn = (char *)idat.PopD();
    int fh;

    if((fh = _open(fn,  fam)) != (-1))
    {
       idat.PushD(fh);
       idat.PushD(0L);
       return;
    }
    idat.PushD(fh);
    idat.PushD(errno);
}

void Primitives::L_FileSize(InterpreterData & idat)
{
  int nf = (int) idat.PopD();
  long nn = _filelength(nf);
  idat.PushD(nn);
  if(nn == (-1))
  {
    idat.PushD(-1);
    return;
  }
  idat.PushD(0L);
}

void Primitives::L_FilePosition(InterpreterData & idat)
{
    int nf = (int) idat.PopD();
    long newpos = idat.PopD();
    long fp = _lseek( nf, newpos, SEEK_SET );
    idat.PushD(fp);
    if(fp == (-1))
    {
      idat.PushD(errno);
     return;
    }
   idat.PushD(0L);

}

void Primitives::L_RepositionFile(InterpreterData & idat)
{
    int nf = (int) idat.PopD();
    long fp = _lseek( nf, 0, SEEK_CUR );
    idat.PushD(fp);
    if(fp == (-1))
    {
      idat.PushD(errno);
     return;
    }
   idat.PushD(0L);

}

void Primitives::L_ReadFile(InterpreterData & idat)
{
  int nf = (int) idat.PopD();
  long rs = idat.PopD();
  char *buf = (char *) idat.PopD();
  long nn = _read(nf, buf, rs);
  idat.PushD(nn);
  if(nn == (-1))
  {
    idat.PushD(errno);
    return;
  }
  idat.PushD(0L);
}

void Primitives::L_WriteFile(InterpreterData & idat)
{
  int nf = (int) idat.PopD();
  long rs = idat.PopD();
  char *buf = (char *) idat.PopD();
  long nn = _write(nf, buf, rs);
  idat.PushD(nn);
  if(nn == (-1))
  {
    idat.PushD(errno);
    return;
  }
  idat.PushD(0L);
}

void Primitives::L_CloseFile(InterpreterData & idat)
{
   long fid = idat.PopD();
   int nn = close((int)fid);
   idat.PushD((long)nn);
}

void Primitives::L_ShowFileError(InterpreterData & idat)
{
  long fer = idat.PopD();
  idat.ErrNumberError(fer);
}

// Function name	: Primitives::L_evaluate
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_evaluate(InterpreterData & idat)
{
  long uu = idat.PopD();
  char *cc = (char *) idat.PopD();
  idat.Parse(cc, false, "evaluate");
//  idat.ResetFatal();
}


// Function name	: Primitives::L_include
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_include(InterpreterData & idat)
{

  string *fnam = (string *) idat.PopD();
  int nf = -1;
  char fn[256];
  strncpy(fn, fnam->c_str(), 255);
 
  if((nf = _open(fn, _O_RDWR)) != -1)
  {
    long nn = _filelength(nf);
    char * dbuf = new char[nn + 1];
    if(dbuf != NULL)
    {
       memset(dbuf,0,nn + 1);
       read(nf, dbuf, nn);
       idat.DebugTrace(fn);
       idat.DebugTrace(" was read");
       close(nf);
       idat.Parse(dbuf, false, fn);
       delete [] dbuf;   
    }
    else
    {
      idat.DebugTrace(fn);
      idat.DebugTrace("NULL buffer from new");
    }
  }
  else
  {
     idat.DebugTrace(fn);
     idat.DebugTrace(strerror( errno ));
  }
}

// Function name	: Primitives::L_included
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_included(InterpreterData & idat)
{
  int len = idat.PopD();
  char *fnam = (char *) idat.PopD();
  int nf = -1;
  
  if((nf = _open(fnam, _O_RDWR)) != -1)
  {
    long nn = _filelength(nf);
    char * dbuf = new char[nn + 1];
    if(dbuf != NULL)
    {
       memset(dbuf,0,nn + 1);
       _read(nf, dbuf, nn);
       idat.DebugTrace(fnam);
       idat.DebugTrace(" was read");
       close(nf);
       idat.Parse(dbuf, false, fnam);
       delete [] dbuf;   
    }
    else
    {
      idat.DebugTrace(fnam);
      idat.DebugTrace("NULL buffer from new");
    }
  }
  else
  {
     idat.DebugTrace(fnam);
     idat.DebugTrace(strerror( errno ));
  }
}

// STL Interpreter ---------------------------

void Primitives::L_STLVect(InterpreterData & idat)
{
  string awrd;
  Parser * par = idat.IParser();
  char * wrd;

 if((wrd = par->NextWord()) != NULL)
 {
    awrd = wrd;
    unsigned long lval = 0l;
    if(idat.IDict()->Exists(awrd) == -1)  // word does not exist
    {
         if(!par->AllDigits(wrd))         // word is not a number
         { 
           idat.BuildWithName(awrd); 
           STLVect * sv = (STLVect *) idat.MManager().AllocateType(MemInstDat::m_STLVect, 0);
           idat.NamedVects().Insert(awrd, sv);
           lval = (unsigned long) sv;
           idat.BuildAddElement(lval);  
         }
         else
         {
            // trying to name a word with a number error
            idat.ShowError(Errors::IS_NUMBER);
         }
    }
    else
     {
        // word already exists error
        idat.ShowError(Errors::WORD_EXISTS, awrd);
     }
 } 
 else
 {
      // buffer end reached
      idat.ShowError(Errors::BUFFER_END);
 }
}

void Primitives::L_STLMap(InterpreterData & idat)
{
  string awrd;
  Parser * par = idat.IParser();
  char * wrd;

 if((wrd = par->NextWord()) != NULL)
 {
    awrd = wrd;
    unsigned long lval = 0l;
    if(idat.IDict()->Exists(awrd) == -1)  // word does not exist
    {
         if(!par->AllDigits(wrd))         // word is not a number
         { 
           idat.BuildWithName(awrd); 
           STLMap * sv = (STLMap *) idat.MManager().AllocateType(MemInstDat::m_STLMap, 0);
           idat.NamedMaps().Insert(awrd, sv);
           lval = (unsigned long) sv;
           idat.BuildAddElement(lval);  
         }
         else
         {
            // trying to name a word with a number error
            idat.ShowError(Errors::IS_NUMBER);
         }
    }
    else
     {
        // word already exists error
        idat.ShowError(Errors::WORD_EXISTS, awrd);
     }
 } 
 else
 {
      // buffer end reached
      idat.ShowError(Errors::BUFFER_END);
 }
}

void Primitives::L_STLVectIterator(InterpreterData & idat)
{
  string awrd;
  Parser * par = idat.IParser();
  char * wrd;

 if((wrd = par->NextWord()) != NULL)
 {
    awrd = wrd;
    unsigned long lval = 0l;
    if(idat.IDict()->Exists(awrd) == -1)  // word does not exist
    {
         if(!par->AllDigits(wrd))         // word is not a number
         { 
           idat.BuildWithName(awrd); 
           STLVectIterator * sv = (STLVectIterator *) idat.MManager().AllocateType(MemInstDat::m_STLVectIterator, 0);
           lval = (unsigned long) sv;
           idat.BuildAddElement(lval);  
         }
         else
         {
            // trying to name a word with a number error
            idat.ShowError(Errors::IS_NUMBER);
         }
    }
    else
     {
        // word already exists error
        idat.ShowError(Errors::WORD_EXISTS, awrd);
     }
 } 
 else
 {
      // buffer end reached
      idat.ShowError(Errors::BUFFER_END);
 }
}


void Primitives::L_STLMapIterator(InterpreterData & idat)
{
  string awrd;
  Parser * par = idat.IParser();
  char * wrd;

 if((wrd = par->NextWord()) != NULL)
 {
    awrd = wrd;
    unsigned long lval = 0l;
    if(idat.IDict()->Exists(awrd) == -1)  // word does not exist
    {
         if(!par->AllDigits(wrd))         // word is not a number
         { 
           idat.BuildWithName(awrd); 
           STLMapIterator * sv = (STLMapIterator *) idat.MManager().AllocateType(MemInstDat::m_STLMapIterator, 0);
           lval = (unsigned long) sv;
           idat.BuildAddElement(lval);  
         }
         else
         {
            // trying to name a word with a number error
            idat.ShowError(Errors::IS_NUMBER);
         }
    }
    else
     {
        // word already exists error
        idat.ShowError(Errors::WORD_EXISTS);
     }
 } 
 else
 {
      // buffer end reached
      idat.ShowError(Errors::BUFFER_END);
 }
}


// Function name	: Primitives::L_STLInsert
// Description	    : for maps
//                    ( ld key &stlobj --- true | false ) 
//                    for vectors
//                    ( ld iterator &stlobj --- changed_iterator )
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_STLInsert(InterpreterData & idat)
{
  long kv;
  unsigned long lv;
  STLVectIterator* li;
  void * pl = (void *) idat.PopD();
  int ii = idat.MManager().Typeof(pl);
  STLMap * sp = NULL;
  STLVect * vp = NULL;
  bool tf = false;

  switch(ii)
  {
    case MemInstDat::m_STLMap:
          sp = (STLMap *) pl; 
          kv =  idat.PopD();
          lv = idat.PopD();          
          tf = sp->Insert(kv, lv);
          idat.PushD((long)tf);
        break;
    case MemInstDat::m_STLVect:
          vp = (STLVect *) pl; 
          li = (STLVectIterator*) idat.PopD();
          lv = idat.PopD();
          *li = vp->Insert(li->GetIt(), lv);
          idat.PushD((long)li);
        break;
    default:
        idat.ShowError(Errors::STL_ERROR);
        break;
  }
}

// Function name	: Primitives::L_STLFind
// Description	    : ( dat iterator &stlobj --- iterator true | false)
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_STLFind(InterpreterData & idat)
{
  long dv;
  STLVectIterator* iv;
  STLMapIterator* jv;
  void * pl = (void *) idat.PopD();
  int ii = idat.MManager().Typeof(pl);
  STLMap * sp = NULL;
  STLVect * vp = NULL;

  switch(ii)
  {
    case MemInstDat::m_STLMap:
          sp = (STLMap *) pl; 
          jv = (STLMapIterator*) idat.PopD();
          dv = idat.PopD(); 
          *jv = sp->Find(dv);
          if((*jv) == sp->End())
          {
            idat.PushD((long)false);
          }
          else
          {
            idat.PushD((unsigned long)(jv));
            idat.PushD(true);
          }
        break;
    case MemInstDat::m_STLVect:
          vp = (STLVect *) pl; 
          iv = (STLVectIterator*) idat.PopD();
          dv = idat.PopD();
          *iv = vp->Find(dv);
          if((*iv) == vp->End())
          {
            idat.PushD((long)false);
          }
          else
          {
            idat.PushD((long)iv);
            idat.PushD((long)true);
          }

        break;
    default:
        idat.ShowError(Errors::STL_ERROR);
        break;
  }
}


// Function name	: Primitives::L_STLBegin
// Description	    : (iterator &stlobj -- iterator)
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_STLBegin(InterpreterData & idat)
{
  STLVectIterator* iv;
  STLMapIterator* jv;
  void * pl = (void *) idat.PopD();
  int ii = idat.MManager().Typeof(pl);
  STLMap * sp = NULL;
  STLVect * vp = NULL;

  switch(ii)
  {
    case MemInstDat::m_STLMap:
        {
          sp = (STLMap *) pl; 
          jv = (STLMapIterator*) idat.PopD();
          *jv = sp->Begin();
          idat.PushD((unsigned long)(jv));
        }
        break;
    case MemInstDat::m_STLVect:
        {
          vp = (STLVect *) pl; 
          iv = (STLVectIterator*) idat.PopD();
          *iv = vp->Begin();
          idat.PushD((unsigned long)(iv));
        }
        break;
    default:
        idat.ShowError(Errors::STL_ERROR);
        break;
  }
}


// Function name	: Primitives::L_STLEnd
// Description	    : (iterator &stlobj -- iterator)
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_STLEnd(InterpreterData & idat)
{
  STLVectIterator* iv;
  STLMapIterator* jv;
  void * pl = (void *) idat.PopD();
  int ii = idat.MManager().Typeof(pl);
  STLMap * sp = NULL;
  STLVect * vp = NULL;

  switch(ii)
  {
    case MemInstDat::m_STLMap:
          sp = (STLMap *) pl; 
          jv = (STLMapIterator*) idat.PopD();
          *jv = sp->End();
          idat.PushD((unsigned long)(jv));
        break;
    case MemInstDat::m_STLVect:
          vp = (STLVect *) pl; 
          iv = (STLVectIterator*) idat.PopD();
          *iv = vp->End();
          idat.PushD((unsigned long)(iv));
        break;
    default:
        idat.ShowError(Errors::STL_ERROR);
        break;
  }
}


// Function name	: Primitives::L_STLItfrom
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_STLItFrom(InterpreterData & idat)
{
  long lv;
  STLVectIterator* iv;
  STLMapIterator* jv;
  void * pl = (void *) idat.PopD();
  int ii = idat.MManager().Typeof(pl);
 
  switch(ii)
  {
    case MemInstDat::m_STLMapIterator:
          jv = (STLMapIterator*) pl;
          lv = (*(jv->GetIt())).second;
          idat.PushD((unsigned long)(lv));
        break;
    case MemInstDat::m_STLVectIterator:
          iv = (STLVectIterator*) pl;
          lv = *(iv->GetIt());
          idat.PushD((unsigned long)(lv));
        break;
    default:
        idat.ShowError(Errors::STL_ERROR);
        break;
  }
}

void Primitives::L_STLItInc(InterpreterData & idat)
{
  STLVectIterator* iv;
  STLMapIterator* jv;
  void * pl = (void *) idat.PopD();
  int ii = idat.MManager().Typeof(pl);

  switch(ii)
  {
    case MemInstDat::m_STLMapIterator:
          jv = (STLMapIterator*) pl;
          (*jv).GetIt()++;
          idat.PushD((unsigned long)(jv));
        break;
    case MemInstDat::m_STLVectIterator:
          iv = (STLVectIterator*) pl;
          (*iv).GetIt()++;
          idat.PushD((unsigned long)(iv));
        break;
    default:
        idat.ShowError(Errors::STL_ERROR);
        break;
  }
}

void Primitives::L_STLItEquals(InterpreterData & idat)
{
  STLVectIterator* iv, *iv2;
  STLMapIterator* jv, *jv2;
  void * pl = (void *) idat.PopD();
  void * rl = (void *) idat.PopD();
  int ii = idat.MManager().Typeof(pl);
  int jj = idat.MManager().Typeof(rl);
  if(ii != jj)
  {
    idat.ShowError(Errors::STL_ERROR);
    idat.PushD((long)false);
    return;
  }

  switch(ii)
  {
    case MemInstDat::m_STLMapIterator:
          jv = (STLMapIterator*) pl;
          jv2 = (STLMapIterator*) rl;
          if((*jv).GetIt() == (*jv2).GetIt())
          {
            idat.PushD(true); 
            return;
          }
        break;
    case MemInstDat::m_STLVectIterator:
          iv = (STLVectIterator*) pl;
          iv2 = (STLVectIterator*) rl;
          if((*iv2).GetIt() == (*iv).GetIt())
          {
            idat.PushD(true);
            return;
          }
        break;
    default:
        idat.ShowError(Errors::STL_ERROR);
        break;
  }
  idat.PushD((long)false);
}


// Function name	: Primitives::L_bye
// Description	    : 
// Return type		: void 
// Argument         : InterpreterData & idat
void Primitives::L_bye(InterpreterData & idat)
{
  _exit(0);
}


// ------------------TO DO --------------
//  vocs, 
//  [compile] words 
// .r u.r erase  move
// abort abort" accept sliteral see evaluate get-current get-order 
// search-wordlist set-current set-order wordlist only order previous 
// key? ekey>char ekey?  2r@ 2r> 2>r compile, catch throw emit? ms 
// /mod */ */mod c, 

// : gi5 begin dup 2 > while dup 5 < while dup 1+ repeat 123 else 345 then ;

// bin close-file create-file delete-file file-position file-size include-file 
// included r/o open-file r/w read-file read-line reposition-file resize-file 
// source-id w/o write-file write-line file-status flush-file rename-file 


//#if _MSC_VER <= 800   
//extern char far *_pgmptr;   
//#else   /#include <stdlib.h>
//#endif

